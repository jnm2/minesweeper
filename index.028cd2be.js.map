{"mappings":"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","sources":["src/game.ts","src/minesweeperLayout.ts","src/renderer.ts","src/index.ts"],"sourcesContent":["export class UnknownCell {\n    constructor(readonly marked: boolean) {\n    }\n}\n\nexport class OpenCell {\n    constructor(readonly mineCount: number) {\n    }\n}\n\nexport class ExplodedCell { }\n\nexport type CellCoords = { x: number, y: number };\n\nexport class Game {\n    private stateMap: (undefined | 'marked' | 'revealed')[][];\n    private mineMap: ('bomb' | number)[][] | null;\n    private remainingToOpen: number;\n    private gameConclusion: (null | 'win' | 'loss');\n\n    constructor(readonly width: number, readonly height: number, readonly mineCount: number) {\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n\n        this.stateMap = new Array(height);\n        for (let y = 0; y < height; y++)\n            this.stateMap[y] = new Array(width);\n\n        this.mineMap = null;\n    }\n\n    get conclusion(): null | 'win' | 'loss' { return this.gameConclusion; }\n\n    getCellAt(x: number, y: number): UnknownCell | ExplodedCell | OpenCell {\n        const state = this.stateMap[y][x];\n\n        if (state !== 'revealed')\n            return new UnknownCell(state === 'marked');\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n        return contents === 'bomb' ? new ExplodedCell() : new OpenCell(contents);\n    }\n\n    tryToggleMark(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed') return false;\n\n        this.stateMap[y][x] = state === 'marked' ? undefined : 'marked';\n        return true;\n    }\n\n    tryOpen(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed' || state === 'marked') return false;\n\n        if (this.mineMap === null)\n            this.initializeMines({ x, y });\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n\n        if (contents === 'bomb')\n            this.explode();\n        else\n            this.openKnownGoodCell(x, y);\n\n        return true;\n    }\n\n    openSurroundingIfSatisfied(x: number, y: number): boolean {\n        const cell = this.getCellAt(x, y);\n\n        if (cell instanceof OpenCell) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n\n            const openable = new Array<CellCoords>();\n            let markCount = 0;\n\n            for (let i = 0; i < surroundingCoords.length; i++) {\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n\n                if (state === 'marked') {\n                    markCount++;\n                } else if (state !== 'revealed') {\n                    openable.push(coords);\n                }\n            }\n\n            if (markCount === cell.mineCount) {\n                for (let i = 0; i < openable.length; i++) {\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private initializeMines(guaranteedCell: CellCoords) {\n        this.mineMap = new Array(this.height);\n        for (let y = 0; y < this.height; y++)\n            this.mineMap[y] = new Array(this.width).fill(0);\n\n        for (let plantedCount = 0; plantedCount < this.mineCount;) {\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === 'bomb') continue;\n\n            this.mineMap[y][x] = 'bomb';\n\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for (let i = 0; i < allSurrounding.length; i++) {\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== 'bomb')\n                    this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n\n            plantedCount++;\n        }\n\n        console.log(this.mineMap);\n    }\n\n    private explode() {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        this.gameConclusion = 'loss';\n\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.mineMap[y][x] === 'bomb') {\n                    this.stateMap[y][x] = 'revealed';\n                }\n            }\n        }\n    }\n\n    private openKnownGoodCell(x: number, y: number) {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        let knownGoodCells = [{ x, y }];\n\n        for (;;) {\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === 'marked' || state === 'revealed') continue;\n\n            this.stateMap[cell.y][cell.x] = 'revealed';\n\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = 'win';\n\n                for (let y = 0; y < this.height; y++) {\n                    for (let x = 0; x < this.width; x++) {\n                        if (this.mineMap[y][x] === 'bomb') {\n                            this.stateMap[y][x] = 'marked';\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            if (this.mineMap[cell.y][cell.x] === 0)\n                knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n\n    private getSurroundingCoordinates(x: number, y: number) {\n        const coordinates = new Array<CellCoords>();\n\n        if (y > 0)\n            coordinates.push({ x, y: y - 1 });\n        if (y < this.height - 1)\n            coordinates.push({ x, y: y + 1 });\n\n        if (x > 0) {\n            coordinates.push({ x: x - 1, y });\n            if (y > 0)\n                coordinates.push({ x: x - 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x - 1, y: y + 1 });\n        }\n\n        if (x < this.width - 1) {\n            coordinates.push({ x: x + 1, y });\n            if (y > 0)\n                coordinates.push({ x: x + 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x + 1, y: y + 1 });\n        }\n\n        return coordinates;\n    }\n}\n","export type Rectangle = { x: number, y: number, width: number, height: number };\n\nexport class MinesweeperLayout {\n    readonly renderSize: { width: number, height: number };\n    readonly gameSize: { width: number, height: number };\n    readonly cellSize: number;\n    readonly minefieldBounds: Rectangle;\n\n    constructor(renderWidth: number, renderHeight: number, gameWidth: number, gameHeight: number) {\n        this.renderSize = { width: renderWidth, height: renderHeight };\n        this.gameSize = { width: gameWidth, height: gameHeight };\n\n        const outerBounds = { x: 0, y: 0, width: this.renderSize.width, height: this.renderSize.height };\n        const aspect = { width: gameWidth, height: gameHeight };\n        this.minefieldBounds = MinesweeperLayout.fitRectangle(aspect, outerBounds);\n\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n\n    getCellCoordinatesByMouseLocation(mouseLocation: { x: number, y: number }): { x: number, y: number } | null {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n\n        return { x, y };\n    }\n\n    getCellBorderX(cellX: number): number {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n\n    getCellBorderY(cellY: number): number {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n\n    getCellBounds(cellX: number, cellY: number): { x: number, y: number, width: number, height: number } {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n\n        return {\n            x,\n            y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y,\n        };\n    }\n\n    private static fitRectangle(aspect: { width: number, height: number }, outerBounds: Rectangle) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            const correctedHeight = outerBounds.width * aspect.height / aspect.width;\n\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight,\n            };\n        } else {\n            const correctedWidth = outerBounds.height * aspect.width / aspect.height;\n\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height,\n            };\n        }\n    }\n}\n","import { Game, UnknownCell, OpenCell, CellCoords } from './game';\nimport { MinesweeperLayout, Rectangle } from './minesweeperLayout';\n\nexport class Renderer {\n    private readonly game: Game;\n    private readonly minefieldContainer: HTMLElement;\n    private readonly context: CanvasRenderingContext2D;\n    private layout!: MinesweeperLayout;\n    private mouseDownCell: CellCoords | null = null;\n    private isMouseCaptured = false;\n\n    constructor(game: Game, minefieldContainer: HTMLElement) {\n        this.game = game;\n\n        const canvas = document.createElement('canvas');\n        canvas.style.touchAction = 'manipulation';\n\n        const context = canvas.getContext('2d');\n        if (!context) throw 'Unable to obtain a 2D drawing context.';\n        this.context = context;\n\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n\n        window.addEventListener('resize', () => this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n\n        canvas.addEventListener('mousedown', ev => this.onMouseDown(ev));\n        canvas.addEventListener('mousemove', ev => this.onMouseMove(ev));\n        canvas.addEventListener('mouseup', ev => this.onMouseUp(ev));\n        canvas.addEventListener('dblclick', ev => this.onDoubleClick(ev));\n        canvas.addEventListener('contextmenu', ev => this.onContextMenu(ev), false);\n    }\n\n    private refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n\n        if (this.layout\n            && this.layout.renderSize.width === devicePixelWidth\n            && this.layout.renderSize.height === devicePixelHeight) {\n            return;\n        }\n\n        this.layout = new MinesweeperLayout(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + 'px';\n        canvas.style.height = this.minefieldContainer.clientHeight + 'px';\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n\n    private onContextMenu(ev: MouseEvent) {\n        ev.preventDefault();\n        if (this.game.conclusion) return;\n\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (coords && this.game.tryToggleMark(coords.x, coords.y))\n            this.render();\n    }\n\n    private onMouseDown(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        }\n\n        // Right-click is already handled by the contextmenu event which is the only way to get long presses working in\n        // touch interfaces, synced to the haptic feedback. Haven’t found a good way to distinguish right-click from\n        // long press. Waiting until mouseup to mark the cell is at least consistent with how left-click behaves.\n    }\n\n    private onMouseMove(ev: MouseEvent) {\n        if (this.isMouseCaptured)\n            this.updateMouseDownCell(ev);\n    }\n\n    private onMouseUp(ev: MouseEvent) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n\n            if (this.mouseDownCell) {\n                this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n\n    private onDoubleClick(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y))\n                this.render();\n        }\n    }\n\n    private updateMouseDownCell(ev: MouseEvent) {\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (!Renderer.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n\n    private static areSame(first: CellCoords | null, second: CellCoords | null) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n\n    private getCellByMouseLocation(ev: MouseEvent) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio,\n        });\n    }\n\n    render(): void {\n        const { renderSize, minefieldBounds, cellSize } = this.layout;\n\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n\n        this.context.fillStyle = '#d0d0d0';\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n\n        this.context.strokeStyle = '#a0a0a0';\n\n        for (let y = 0; y < this.game.height; y++) {\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n\n        for (let x = 0; x < this.game.width; x++) {\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n\n        this.context.font = 'bold ' + (cellSize * 0.5) + 'px Georgia';\n\n        for (let y = 0; y < this.game.height; y++) {\n            for (let x = 0; x < this.game.width; x++) {\n                this.drawCell({ x, y }, this.layout.getCellBounds(x, y), cellSize);\n            }\n        }\n    }\n\n    private drawCell(coords: CellCoords, cellBounds: Rectangle, cellSize: number) {\n        const { x, y } = coords;\n\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n\n        const cell = this.game.getCellAt(x, y);\n\n        if (cell instanceof UnknownCell && (cell.marked || !isMouseDown)) {\n            const borderSize = cellSize * 0.1;\n\n            const right = cellBounds.x + cellBounds.width;\n            const bottom = cellBounds.y + cellBounds.height;\n\n            this.context.beginPath();\n            this.context.moveTo(cellBounds.x, cellBounds.y);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.closePath();\n            this.context.fillStyle = '#e8e8e8';\n            this.context.fill();\n\n            this.context.beginPath();\n            this.context.moveTo(right, bottom);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.closePath();\n            this.context.fillStyle = '#a0a0a0';\n            this.context.fill();\n        }\n\n        const text\n            = cell instanceof UnknownCell ? (cell.marked ? '🚩' : null)\n                : cell instanceof OpenCell ? (cell.mineCount !== 0 ? cell.mineCount.toString() : null)\n                    : '💥';\n\n        if (text !== null) {\n            if (cell instanceof OpenCell)\n                this.context.fillStyle = ['blue', 'green', '#e00', 'darkblue', 'brown', 'darkcyan', 'black', 'gray'][cell.mineCount - 1];\n\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n\n    private drawCenteredText(text: string, bounds: Rectangle) {\n        const metrics = this.context.measureText(text);\n        this.context.textBaseline = 'middle';\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n","import { Game } from './game';\nimport { Renderer } from './renderer';\n\nconst game = new Game(30, 16, 99);\n\nnew Renderer(game, document.getElementById('minefield-container')!);\n"],"names":["$e46db5192eb49d53$export$eaa779a0e5689fc5","marked","$e46db5192eb49d53$export$3b1d32246777906f","mineCount","$e46db5192eb49d53$export$ce2e3e0cb02af144","$7e3eb9e0d162670a$export$563248cf1b99493a","renderWidth","renderHeight","gameWidth","gameHeight","this","renderSize","width","height","gameSize","outerBounds","x","y","aspect","minefieldBounds","fitRectangle","cellSize","getCellCoordinatesByMouseLocation","mouseLocation","Math","floor","getCellBorderX","cellX","getCellBorderY","cellY","getCellBounds","correctedHeight","correctedWidth","$621f3774f67738fc$export$88530751e3977073","game","minefieldContainer","mouseDownCell","isMouseCaptured","canvas","document","createElement","style","touchAction","context","getContext","appendChild","window","addEventListener","refreshCanvasLayout","ev","onMouseDown","onMouseMove","onMouseUp","onDoubleClick","onContextMenu","devicePixelRatio","devicePixelWidth","clientWidth","devicePixelHeight","clientHeight","layout","render","preventDefault","conclusion","coords","getCellByMouseLocation","tryToggleMark","button","updateMouseDownCell","tryOpen","openSurroundingIfSatisfied","areSame","first","second","offsetX","offsetY","clearRect","fillStyle","fillRect","strokeStyle","pixelY","beginPath","moveTo","lineTo","stroke","pixelX","font","y1","x1","drawCell","cellBounds","isMouseDown","cell","getCellAt","borderSize","right","bottom","closePath","fill","text","toString","drawCenteredText","bounds","metrics","measureText","textBaseline","fillText","$b4e14b6b8da86996$var$game","remainingToOpen","gameConclusion","stateMap","Array","mineMap","state","contents","undefined","initializeMines","explode","openKnownGoodCell","surroundingCoords","getSurroundingCoordinates","openable","markCount","i","length","push","guaranteedCell","plantedCount","random","abs","allSurrounding","surrounding","console","log","knownGoodCells","pop","concat","coordinates","getElementById"],"version":3,"file":"index.028cd2be.js.map"}