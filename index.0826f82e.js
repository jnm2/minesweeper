class e{constructor(e){this.marked=e}}class t{constructor(e){this.mineCount=e}}class i{}class s{constructor(e,t,i){this.width=e,this.height=t,this.mineCount=i,this.remainingToOpen=e*t-i,this.gameConclusion=null,this.stateMap=Array(t);for(let i=0;i<t;i++)this.stateMap[i]=Array(e);this.mineMap=null}get conclusion(){return this.gameConclusion}getCellAt(s,o){let l=this.stateMap[o][s];if("revealed"!==l)return new e("marked"===l);if(!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";let h=this.mineMap[o][s];return"bomb"===h?new i:new t(h)}tryToggleMark(e,t){let i=this.stateMap[t][e];return"revealed"!==i&&(this.stateMap[t][e]="marked"===i?void 0:"marked",!0)}canOpen(e,t){let i=this.stateMap[t][e];return"revealed"!==i&&"marked"!==i}tryOpen(e,t){if(!this.canOpen(e,t))return!1;if(null===this.mineMap&&this.initializeMines({x:e,y:t}),!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";return"bomb"===this.mineMap[t][e]?this.explode():this.openKnownGoodCell(e,t),!0}openSurroundingIfSatisfied(e,i){let s=this.getCellAt(e,i);if(s instanceof t){let t=this.getSurroundingCoordinates(e,i),o=[],l=0;for(let e=0;e<t.length;e++){let i=t[e],s=this.stateMap[i.y][i.x];"marked"===s?l++:"revealed"!==s&&o.push(i)}if(l===s.mineCount){for(let e=0;e<o.length;e++){let t=o[e];if(this.tryOpen(t.x,t.y),this.gameConclusion)break}return!0}}return!1}initializeMines(e){this.mineMap=Array(this.height);for(let e=0;e<this.height;e++)this.mineMap[e]=Array(this.width).fill(0);for(let t=0;t<this.mineCount;){let i=Math.floor(Math.random()*this.width),s=Math.floor(Math.random()*this.height);if(1>=Math.abs(i-e.x)&&1>=Math.abs(s-e.y)||"bomb"===this.mineMap[s][i])continue;this.mineMap[s][i]="bomb";let o=this.getSurroundingCoordinates(i,s);for(let e=0;e<o.length;e++){let t=o[e],i=this.mineMap[t.y][t.x];"bomb"!==i&&(this.mineMap[t.y][t.x]=i+1)}t++}}explode(){if(!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";this.gameConclusion="loss";for(let e=0;e<this.height;e++)for(let t=0;t<this.width;t++)"bomb"===this.mineMap[e][t]&&(this.stateMap[e][t]="revealed")}openKnownGoodCell(e,t){if(!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";let i=[{x:e,y:t}];for(;;){let e=i.pop();if(!e)break;let t=this.stateMap[e.y][e.x];if("marked"!==t&&"revealed"!==t){if(this.stateMap[e.y][e.x]="revealed",this.remainingToOpen--,0===this.remainingToOpen){this.gameConclusion="win";for(let e=0;e<this.height;e++)for(let t=0;t<this.width;t++)"bomb"===this.mineMap[e][t]&&(this.stateMap[e][t]="marked");break}0===this.mineMap[e.y][e.x]&&(i=i.concat(this.getSurroundingCoordinates(e.x,e.y)))}}}getSurroundingCoordinates(e,t){let i=[];return t>0&&i.push({x:e,y:t-1}),t<this.height-1&&i.push({x:e,y:t+1}),e>0&&(i.push({x:e-1,y:t}),t>0&&i.push({x:e-1,y:t-1}),t<this.height-1&&i.push({x:e-1,y:t+1})),e<this.width-1&&(i.push({x:e+1,y:t}),t>0&&i.push({x:e+1,y:t-1}),t<this.height-1&&i.push({x:e+1,y:t+1})),i}}class o{constructor(e,t){this.surroundingBombCount=e,this.surroundingCoords=t}validate(e){let t=0,i=0;for(let{x:s,y:o}of this.surroundingCoords)switch(e.cells[o][s]){case"flag":t++;case void 0:i++}return t<=this.surroundingBombCount&&this.surroundingBombCount<=i}}class l{constructor(e){this.cells=e}static fromGame(s){let o=Array(s.height);for(let l=0;l<o.length;l++){let h=Array(s.width);for(let o=0;o<h.length;o++){let n=s.getCellAt(o,l);h[o]=n instanceof e?n.marked?"flag":void 0:n instanceof i?"flag":n instanceof t?n.mineCount:void 0}o[l]=h}return new l(o)}getCellAt(e){return this.cells[e.y][e.x]}getSurroundingCellCoords(e,t){return[{x:e-1,y:t-1},{x:e,y:t-1},{x:e+1,y:t-1},{x:e-1,y:t},{x:e+1,y:t},{x:e-1,y:t+1},{x:e,y:t+1},{x:e+1,y:t+1}].filter(e=>e.x>=0&&e.y>=0&&e.y<this.cells.length&&e.x<this.cells[e.y].length)}getFlagCount(){let e=0;for(let t=0;t<this.cells.length;t++)for(let i=0;i<this.cells[t].length;i++)"flag"===this.cells[t][i]&&e++;return e}getUnopenedUnflaggedCount(){let e=0;for(let t=0;t<this.cells.length;t++)for(let i=0;i<this.cells[t].length;i++)void 0===this.cells[t][i]&&e++;return e}getValidMapWith(e,t){let i=this.cells.slice(),s=i[t.y].slice();s[t.x]=e,i[t.y]=s;let h=new l(i);for(let e of h.getSurroundingCellCoords(t.x,t.y)){let t=h.getCellAt(e);if("number"==typeof t&&!new o(t,h.getSurroundingCellCoords(e.x,e.y)).validate(h))return null}return h}validateAll(e){let t=0,i=0;for(let s=0;s<this.cells.length;s++)for(let l=0;l<this.cells[s].length;l++){let h=this.cells[s][l];if("number"==typeof h){if(!new o(h,this.getSurroundingCellCoords(l,s)).validate(this))return!1}else if("flag"===h){if(++t>e)return!1}else i++}return i+t>=e}}class h{constructor(e,t){this.candidates=e,this.bombLikelihoodElsewhere=t}getBombLikelihood(e,t){return this.candidates.find(i=>i.x===e&&i.y===t)?.bombLikelihood??this.bombLikelihoodElsewhere}static compute(e){let t=e instanceof s?l.fromGame(e):e.map,i=function(e){let t=[];for(let i=0;i<e.cells.length;i++)for(let s=0;s<e.cells[i].length;s++)void 0===e.cells[i][s]&&e.getSurroundingCellCoords(s,i).some(t=>"number"==typeof e.getCellAt(t))&&t.push({x:s,y:i});return t}(t),o=[];if(t.validateAll(e.mineCount)&&function t(s,l,h){if(null===s)return;let n=function(e){for(let t of i)if(void 0===e.getCellAt(t))return t}(s);if(void 0===n){o.push(s);return}h>e.mineCount-l&&t(s.getValidMapWith("safe",n),l,h-1),l<e.mineCount&&t(s.getValidMapWith("flag",n),l+1,h-1)}(t,t.getFlagCount(),t.getUnopenedUnflaggedCount()),0===o.length)return new h([]);let n=o.reduce((e,t)=>e+t.getFlagCount(),0)/o.length,a=e.mineCount-n,r=t.getUnopenedUnflaggedCount()-i.length;return new h(i.map(e=>({...e,bombLikelihood:o.reduce((t,i)=>t+("flag"===i.getCellAt(e)?1:0),0)/o.length})),a/r)}}class n{constructor(e,t,i,s){this.renderSize={width:e,height:t},this.gameSize={width:i,height:s};let o={x:0,y:0,width:this.renderSize.width,height:this.renderSize.height};this.minefieldBounds=n.fitRectangle({width:i,height:s},o),this.cellSize=this.minefieldBounds.width/i}getCellCoordinatesByMouseLocation(e){let t=Math.floor((e.x-this.minefieldBounds.x)/this.cellSize);if(t<0||t>=this.gameSize.width)return null;let i=Math.floor((e.y-this.minefieldBounds.y)/this.cellSize);return i<0||i>=this.gameSize.height?null:{x:t,y:i}}getCellBorderX(e){return Math.floor(this.minefieldBounds.x+this.cellSize*e)}getCellBorderY(e){return Math.floor(this.minefieldBounds.y+this.cellSize*e)}getCellBounds(e,t){let i=this.getCellBorderX(e),s=this.getCellBorderY(t);return{x:i,y:s,width:this.getCellBorderX(e+1)-i,height:this.getCellBorderY(t+1)-s}}static fitRectangle(e,t){if(t.width*e.height<t.height*e.width){let i=t.width*e.height/e.width;return{x:0,y:(t.height-i)/2,width:t.width,height:i}}{let i=t.height*e.width/e.height;return{x:(t.width-i)/2,y:0,width:i,height:t.height}}}}class a{constructor(e,t){this.mouseDownCell=null,this.isMouseCaptured=!1,this.heatmap=null,this.drawHeatmap=!1,this.alwaysDrawHeatmap=!1,this.drawBestMoves=!1,this.alwaysDrawBestMoves=!1,this.teachBestMoves=!1,this.autoFlag=!1,this.autoOpen=!1,this.game=e;let i=document.createElement("canvas");i.style.touchAction="manipulation";let s=i.getContext("2d");if(!s)throw"Unable to obtain a 2D drawing context.";this.context=s,this.minefieldContainer=t,t.appendChild(i),window.addEventListener("resize",()=>this.refreshCanvasLayout()),this.refreshCanvasLayout(),i.addEventListener("mousedown",e=>this.onMouseDown(e)),i.addEventListener("mousemove",e=>this.onMouseMove(e)),i.addEventListener("mouseup",e=>this.onMouseUp(e)),i.addEventListener("dblclick",e=>this.onDoubleClick(e)),i.addEventListener("contextmenu",e=>this.onContextMenu(e),!1),window.addEventListener("keypress",e=>this.onKeyPress(e))}refreshCanvasLayout(){let e=window.devicePixelRatio||1,t=this.minefieldContainer.clientWidth*e,i=this.minefieldContainer.clientHeight*e;if(this.layout&&this.layout.renderSize.width===t&&this.layout.renderSize.height===i)return;this.layout=new n(t,i,this.game.width,this.game.height);let s=this.context.canvas;s.style.width=this.minefieldContainer.clientWidth+"px",s.style.height=this.minefieldContainer.clientHeight+"px",s.width=t,s.height=i,this.render()}onContextMenu(e){if(e.preventDefault(),this.game.conclusion)return;let t=this.getCellByMouseLocation(e);t&&this.game.tryToggleMark(t.x,t.y)&&(this.afterMove(),this.render())}onMouseDown(e){this.game.conclusion||0!==e.button||(this.isMouseCaptured=!0,this.updateMouseDownCell(e))}onMouseMove(e){this.isMouseCaptured&&this.updateMouseDownCell(e)}onMouseUp(e){if(0===e.button&&(this.isMouseCaptured=!1,this.mouseDownCell)){if(this.game.canOpen(this.mouseDownCell.x,this.mouseDownCell.y)){let e=!1;if(this.teachBestMoves&&!this.drawBestMoves&&null!==this.heatmap){let t=this.heatmap.getBombLikelihood(this.mouseDownCell.x,this.mouseDownCell.y);void 0!==t&&t>this.getBestMoveLoseLikelihood()&&(this.drawBestMoves=!0,e=!0)}e||(this.game.tryOpen(this.mouseDownCell.x,this.mouseDownCell.y),this.afterMove())}this.mouseDownCell=null,this.render()}}onKeyPress(e){switch(e.key){case"h":this.drawHeatmap=!this.drawHeatmap,this.render();break;case"H":this.alwaysDrawHeatmap=!this.alwaysDrawHeatmap,this.drawHeatmap=this.alwaysDrawHeatmap,this.render();break;case"b":this.drawBestMoves=!this.drawBestMoves,this.render();break;case"B":this.alwaysDrawBestMoves=!this.alwaysDrawBestMoves,this.drawBestMoves=this.alwaysDrawBestMoves,this.render();break;case"t":this.teachBestMoves=!this.teachBestMoves;break;case"a":this.autoFlag=!this.autoFlag,this.automate();break;case"A":this.autoOpen=!this.autoOpen,this.automate()}}afterMove(){this.alwaysDrawHeatmap||(this.drawHeatmap=!1),this.alwaysDrawBestMoves||(this.drawBestMoves=!1),this.heatmap=h.compute(this.game),this.automate()}automate(){if(null===this.heatmap)return;let e=!1;for(;;){let t=!1;if(this.autoFlag)for(let e of this.heatmap.candidates)1===e.bombLikelihood&&(this.game.tryToggleMark(e.x,e.y),t=!0);if(this.autoOpen)for(let e of this.heatmap.candidates)0===e.bombLikelihood&&(this.game.tryOpen(e.x,e.y),t=!0);if(!t)break;e=!0,this.heatmap=h.compute(this.game)}e&&this.render()}onDoubleClick(e){if(!this.game.conclusion&&0===e.button){let t=this.getCellByMouseLocation(e);t&&this.game.openSurroundingIfSatisfied(t.x,t.y)&&(this.afterMove(),this.render())}}updateMouseDownCell(e){let t=this.getCellByMouseLocation(e);a.areSame(t,this.mouseDownCell)||(this.mouseDownCell=t,this.render())}static areSame(e,t){return e?!!t&&e.x===t.x&&e.y===t.y:!t}getCellByMouseLocation(e){let t=window.devicePixelRatio||1;return this.layout.getCellCoordinatesByMouseLocation({x:e.offsetX*t,y:e.offsetY*t})}render(){let{renderSize:e,minefieldBounds:t,cellSize:i}=this.layout;this.context.clearRect(0,0,e.width,e.height),this.context.fillStyle="#d0d0d0",this.context.fillRect(t.x,t.y,t.width,t.height),this.context.strokeStyle="#a0a0a0",this.context.lineWidth=1;for(let e=0;e<this.game.height;e++){let i=this.layout.getCellBorderY(e);this.context.beginPath(),this.context.moveTo(t.x,i),this.context.lineTo(t.x+t.width,i),this.context.stroke()}for(let e=0;e<this.game.width;e++){let i=this.layout.getCellBorderX(e);this.context.beginPath(),this.context.moveTo(i,t.y),this.context.lineTo(i,t.y+t.height),this.context.stroke()}this.context.font="bold "+.5*i+"px Georgia";let s=this.drawBestMoves&&null===this.game.conclusion?this.getBestMoveLoseLikelihood():null;for(let e=0;e<this.game.height;e++)for(let t=0;t<this.game.width;t++)this.drawCell({x:t,y:e},this.layout.getCellBounds(t,e),i,s)}getBestMoveLoseLikelihood(){return null===this.heatmap?null:this.heatmap.candidates.some(e=>0===e.bombLikelihood||1===e.bombLikelihood)?0:Math.min(...this.heatmap.candidates.map(e=>e.bombLikelihood),...void 0!==this.heatmap.bombLikelihoodElsewhere?[this.heatmap.bombLikelihoodElsewhere]:[])}drawCell(i,s,o,l){let{x:h,y:n}=i,a=this.mouseDownCell&&this.mouseDownCell.x===h&&this.mouseDownCell.y===n,r=this.game.getCellAt(h,n);if(r instanceof e){if(r.marked||!a){let e=.1*o,t=s.x+s.width,i=s.y+s.height;this.context.beginPath(),this.context.moveTo(s.x,s.y),this.context.lineTo(s.x,i),this.context.lineTo(s.x+e,i-e),this.context.lineTo(s.x+e,s.y+e),this.context.lineTo(t-e,s.y+e),this.context.lineTo(t,s.y),this.context.closePath(),this.context.fillStyle="#e8e8e8",this.context.fill(),this.context.beginPath(),this.context.moveTo(t,i),this.context.lineTo(t,s.y),this.context.lineTo(t-e,s.y+e),this.context.lineTo(t-e,i-e),this.context.lineTo(s.x+e,i-e),this.context.lineTo(s.x,i),this.context.closePath(),this.context.fillStyle="#a0a0a0",this.context.fill()}if(!r.marked){let e=this.heatmap?.getBombLikelihood(h,n);this.drawHeatmap&&void 0!==e&&(this.context.fillStyle=`hsl(${(1-e)*120} 100% 50% / 25%)`,this.context.fillRect(s.x,s.y,s.width,s.height)),null!==l&&(1===e||e===l)&&(this.context.strokeStyle="rgba(255, 255, 0, 0.5)",this.context.lineWidth=6,this.context.strokeRect(s.x+2,s.y+2,s.width-5,s.height-5))}}let d=r instanceof e?r.marked?"\uD83D\uDEA9":null:r instanceof t?0!==r.mineCount?r.mineCount.toString():null:"\uD83D\uDCA5";null!==d&&(r instanceof t?this.context.fillStyle=["blue","green","#e00","darkblue","brown","darkcyan","black","gray"][r.mineCount-1]:this.context.fillStyle="black",this.drawCenteredText(d,s))}drawCenteredText(e,t){let i=this.context.measureText(e);this.context.textBaseline="middle",this.context.fillText(e,t.x+(t.width-i.width)/2,t.y+t.height/2)}}new a(new s(30,16,99),document.getElementById("minefield-container"));
//# sourceMappingURL=index.0826f82e.js.map
