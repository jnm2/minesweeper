!function(){class t{constructor(t){this.marked=t}}class e{constructor(t){this.mineCount=t}}class i{}class n{constructor(t,e,i,s){this.renderSize={width:t,height:e},this.gameSize={width:i,height:s};const o={x:0,y:0,width:this.renderSize.width,height:this.renderSize.height},h={width:i,height:s};this.minefieldBounds=n.fitRectangle(h,o),this.cellSize=this.minefieldBounds.width/i}getCellCoordinatesByMouseLocation(t){const e=Math.floor((t.x-this.minefieldBounds.x)/this.cellSize);if(e<0||e>=this.gameSize.width)return null;const i=Math.floor((t.y-this.minefieldBounds.y)/this.cellSize);return i<0||i>=this.gameSize.height?null:{x:e,y:i}}getCellBorderX(t){return Math.floor(this.minefieldBounds.x+this.cellSize*t)}getCellBorderY(t){return Math.floor(this.minefieldBounds.y+this.cellSize*t)}getCellBounds(t,e){const i=this.getCellBorderX(t),n=this.getCellBorderY(e);return{x:i,y:n,width:this.getCellBorderX(t+1)-i,height:this.getCellBorderY(e+1)-n}}static fitRectangle(t,e){if(e.width*t.height<e.height*t.width){const i=e.width*t.height/t.width;return{x:0,y:(e.height-i)/2,width:e.width,height:i}}{const i=e.height*t.width/t.height;return{x:(e.width-i)/2,y:0,width:i,height:e.height}}}}class s{mouseDownCell=null;isMouseCaptured=!1;constructor(t,e){this.game=t;const i=document.createElement("canvas"),n=i.getContext("2d");if(!n)throw"Unable to obtain a 2D drawing context.";this.context=n,this.minefieldContainer=e,e.appendChild(i),window.addEventListener("resize",(()=>this.refreshCanvasLayout())),this.refreshCanvasLayout(),i.addEventListener("mousedown",(t=>this.onMouseDown(t))),i.addEventListener("mousemove",(t=>this.onMouseMove(t))),i.addEventListener("mouseup",(t=>this.onMouseUp(t))),i.addEventListener("dblclick",(t=>this.onDoubleClick(t))),window.addEventListener("contextmenu",(t=>t.preventDefault()),!1)}refreshCanvasLayout(){const t=window.devicePixelRatio||1,e=this.minefieldContainer.clientWidth*t,i=this.minefieldContainer.clientHeight*t;if(this.layout&&this.layout.renderSize.width===e&&this.layout.renderSize.height===i)return;this.layout=new n(e,i,this.game.width,this.game.height);const s=this.context.canvas;s.style.width=this.minefieldContainer.clientWidth+"px",s.style.height=this.minefieldContainer.clientHeight+"px",s.width=e,s.height=i,this.render()}onMouseDown(t){if(!this.game.conclusion)if(0===t.button)this.isMouseCaptured=!0,this.updateMouseDownCell(t);else if(2===t.button){const e=this.getCellByMouseLocation(t);e&&this.game.tryToggleMark(e.x,e.y)&&this.render()}}onMouseMove(t){this.isMouseCaptured&&this.updateMouseDownCell(t)}onMouseUp(t){0===t.button&&(this.isMouseCaptured=!1,this.mouseDownCell&&(this.game.tryOpen(this.mouseDownCell.x,this.mouseDownCell.y),this.mouseDownCell=null,this.render()))}onDoubleClick(t){if(!this.game.conclusion&&0===t.button){const e=this.getCellByMouseLocation(t);e&&this.game.openSurroundingIfSatisfied(e.x,e.y)&&this.render()}}updateMouseDownCell(t){const e=this.getCellByMouseLocation(t);s.areSame(e,this.mouseDownCell)||(this.mouseDownCell=e,this.render())}static areSame(t,e){return t?!!e&&(t.x===e.x&&t.y===e.y):!e}getCellByMouseLocation(t){const e=window.devicePixelRatio||1;return this.layout.getCellCoordinatesByMouseLocation({x:t.offsetX*e,y:t.offsetY*e})}render(){const{renderSize:t,minefieldBounds:e,cellSize:i}=this.layout;this.context.clearRect(0,0,t.width,t.height),this.context.fillStyle="#d0d0d0",this.context.fillRect(e.x,e.y,e.width,e.height),this.context.strokeStyle="#a0a0a0";for(let t=0;t<this.game.height;t++){const i=this.layout.getCellBorderY(t);this.context.beginPath(),this.context.moveTo(e.x,i),this.context.lineTo(e.x+e.width,i),this.context.stroke()}for(let t=0;t<this.game.width;t++){const i=this.layout.getCellBorderX(t);this.context.beginPath(),this.context.moveTo(i,e.y),this.context.lineTo(i,e.y+e.height),this.context.stroke()}this.context.font="bold "+.5*i+"px Georgia";for(let t=0;t<this.game.height;t++)for(let e=0;e<this.game.width;e++)this.drawCell({x:e,y:t},this.layout.getCellBounds(e,t),i)}drawCell(i,n,s){const{x:o,y:h}=i,l=this.mouseDownCell&&this.mouseDownCell.x===o&&this.mouseDownCell.y===h,a=this.game.getCellAt(o,h);if(a instanceof t&&(a.marked||!l)){const t=.1*s,e=n.x+n.width,i=n.y+n.height;this.context.beginPath(),this.context.moveTo(n.x,n.y),this.context.lineTo(n.x,i),this.context.lineTo(n.x+t,i-t),this.context.lineTo(n.x+t,n.y+t),this.context.lineTo(e-t,n.y+t),this.context.lineTo(e,n.y),this.context.closePath(),this.context.fillStyle="#e8e8e8",this.context.fill(),this.context.beginPath(),this.context.moveTo(e,i),this.context.lineTo(e,n.y),this.context.lineTo(e-t,n.y+t),this.context.lineTo(e-t,i-t),this.context.lineTo(n.x+t,i-t),this.context.lineTo(n.x,i),this.context.closePath(),this.context.fillStyle="#a0a0a0",this.context.fill()}const r=a instanceof t?a.marked?"ðŸš©":null:a instanceof e?0!==a.mineCount?a.mineCount.toString():null:"ðŸ’¥";null!==r&&(a instanceof e&&(this.context.fillStyle=["blue","green","#e00","darkblue","brown","darkcyan","black","gray"][a.mineCount-1]),this.drawCenteredText(r,n))}drawCenteredText(t,e){const i=this.context.measureText(t);this.context.textBaseline="middle",this.context.fillText(t,e.x+(e.width-i.width)/2,e.y+e.height/2)}}const o=new class{constructor(t,e,i){this.width=t,this.height=e,this.mineCount=i,this.remainingToOpen=t*e-i,this.gameConclusion=null,this.stateMap=new Array(e);for(let i=0;i<e;i++)this.stateMap[i]=new Array(t);this.mineMap=null}get conclusion(){return this.gameConclusion}getCellAt(n,s){const o=this.stateMap[s][n];if("revealed"!==o)return new t("marked"===o);if(!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";const h=this.mineMap[s][n];return"bomb"===h?new i:new e(h)}tryToggleMark(t,e){const i=this.stateMap[e][t];return"revealed"!==i&&(this.stateMap[e][t]="marked"===i?void 0:"marked",!0)}tryOpen(t,e){const i=this.stateMap[e][t];if("revealed"===i||"marked"===i)return!1;if(null===this.mineMap&&this.initializeMines({x:t,y:e}),!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";return"bomb"===this.mineMap[e][t]?this.explode():this.openKnownGoodCell(t,e),!0}openSurroundingIfSatisfied(t,i){const n=this.getCellAt(t,i);if(n instanceof e){const e=this.getSurroundingCoordinates(t,i),s=new Array;let o=0;for(let t=0;t<e.length;t++){const i=e[t],n=this.stateMap[i.y][i.x];"marked"===n?o++:"revealed"!==n&&s.push(i)}if(o===n.mineCount){for(let t=0;t<s.length;t++){const e=s[t];if(this.tryOpen(e.x,e.y),this.gameConclusion)break}return!0}}return!1}initializeMines(t){this.mineMap=new Array(this.height);for(let t=0;t<this.height;t++)this.mineMap[t]=new Array(this.width).fill(0);for(let e=0;e<this.mineCount;){const i=Math.floor(Math.random()*this.width),n=Math.floor(Math.random()*this.height);if(Math.abs(i-t.x)<=1&&Math.abs(n-t.y)<=1)continue;if("bomb"===this.mineMap[n][i])continue;this.mineMap[n][i]="bomb";const s=this.getSurroundingCoordinates(i,n);for(let t=0;t<s.length;t++){const e=s[t],i=this.mineMap[e.y][e.x];"bomb"!==i&&(this.mineMap[e.y][e.x]=i+1)}e++}console.log(this.mineMap)}explode(){if(!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";this.gameConclusion="loss";for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)"bomb"===this.mineMap[t][e]&&(this.stateMap[t][e]="revealed")}openKnownGoodCell(t,e){if(!this.mineMap)throw"mineMap should be initialized before any cell state is revealed.";let i=[{x:t,y:e}];for(;;){const t=i.pop();if(!t)break;const e=this.stateMap[t.y][t.x];if("marked"!==e&&"revealed"!==e){if(this.stateMap[t.y][t.x]="revealed",this.remainingToOpen--,0===this.remainingToOpen){this.gameConclusion="win";break}0===this.mineMap[t.y][t.x]&&(i=i.concat(this.getSurroundingCoordinates(t.x,t.y)))}}}getSurroundingCoordinates(t,e){const i=new Array;return e>0&&i.push({x:t,y:e-1}),e<this.height-1&&i.push({x:t,y:e+1}),t>0&&(i.push({x:t-1,y:e}),e>0&&i.push({x:t-1,y:e-1}),e<this.height-1&&i.push({x:t-1,y:e+1})),t<this.width-1&&(i.push({x:t+1,y:e}),e>0&&i.push({x:t+1,y:e-1}),e<this.height-1&&i.push({x:t+1,y:e+1})),i}}(30,16,99);new s(o,document.getElementById("minefield-container"))}();
//# sourceMappingURL=index.a0031635.js.map
