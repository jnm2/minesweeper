{"mappings":"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","sources":["./src/game.ts","./src/minesweeperLayout.ts","./src/index.ts","./src/renderer.ts"],"sourcesContent":["export class UnknownCell {\n    constructor(readonly marked: boolean) {\n    }\n}\n\nexport class OpenCell {\n    constructor(readonly mineCount: number) {\n    }\n}\n\nexport class ExplodedCell { }\n\nexport type CellCoords = { x: number, y: number };\n\nexport class Game {\n    private stateMap: (undefined | 'marked' | 'revealed')[][];\n    private mineMap: ('bomb' | number)[][] | null;\n    private remainingToOpen: number;\n    private gameConclusion: (null | 'win' | 'loss');\n\n    constructor(readonly width: number, readonly height: number, readonly mineCount: number) {\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n\n        this.stateMap = new Array(height);\n        for (let y = 0; y < height; y++)\n            this.stateMap[y] = new Array(width);\n\n        this.mineMap = null;\n    }\n\n    get conclusion(): null | 'win' | 'loss' { return this.gameConclusion; }\n\n    getCellAt(x: number, y: number): UnknownCell | ExplodedCell | OpenCell {\n        const state = this.stateMap[y][x];\n\n        if (state !== 'revealed')\n            return new UnknownCell(state === 'marked');\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n        return contents === 'bomb' ? new ExplodedCell() : new OpenCell(contents);\n    }\n\n    tryToggleMark(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed') return false;\n\n        this.stateMap[y][x] = state === 'marked' ? undefined : 'marked';\n        return true;\n    }\n\n    tryOpen(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed' || state === 'marked') return false;\n\n        if (this.mineMap === null)\n            this.initializeMines({ x, y });\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n\n        if (contents === 'bomb')\n            this.explode();\n        else\n            this.openKnownGoodCell(x, y);\n\n        return true;\n    }\n\n    openSurroundingIfSatisfied(x: number, y: number): boolean {\n        const cell = this.getCellAt(x, y);\n\n        if (cell instanceof OpenCell) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n\n            const openable = new Array<CellCoords>();\n            let markCount = 0;\n\n            for (let i = 0; i < surroundingCoords.length; i++) {\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n\n                if (state === 'marked') {\n                    markCount++;\n                } else if (state !== 'revealed') {\n                    openable.push(coords);\n                }\n            }\n\n            if (markCount === cell.mineCount) {\n                for (let i = 0; i < openable.length; i++) {\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private initializeMines(guaranteedCell: CellCoords) {\n        this.mineMap = new Array(this.height);\n        for (let y = 0; y < this.height; y++)\n            this.mineMap[y] = new Array(this.width).fill(0);\n\n        for (let plantedCount = 0; plantedCount < this.mineCount;) {\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === 'bomb') continue;\n\n            this.mineMap[y][x] = 'bomb';\n\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for (let i = 0; i < allSurrounding.length; i++) {\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== 'bomb')\n                    this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n\n            plantedCount++;\n        }\n\n        console.log(this.mineMap);\n    }\n\n    private explode() {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        this.gameConclusion = 'loss';\n\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.mineMap[y][x] === 'bomb') {\n                    this.stateMap[y][x] = 'revealed';\n                }\n            }\n        }\n    }\n\n    private openKnownGoodCell(x: number, y: number) {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        let knownGoodCells = [{ x, y }];\n\n        for (;;) {\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === 'marked' || state === 'revealed') continue;\n\n            this.stateMap[cell.y][cell.x] = 'revealed';\n\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = 'win';\n                break;\n            }\n\n            if (this.mineMap[cell.y][cell.x] === 0)\n                knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n\n    private getSurroundingCoordinates(x: number, y: number) {\n        const coordinates = new Array<CellCoords>();\n\n        if (y > 0)\n            coordinates.push({ x, y: y - 1 });\n        if (y < this.height - 1)\n            coordinates.push({ x, y: y + 1 });\n\n        if (x > 0) {\n            coordinates.push({ x: x - 1, y });\n            if (y > 0)\n                coordinates.push({ x: x - 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x - 1, y: y + 1 });\n        }\n\n        if (x < this.width - 1) {\n            coordinates.push({ x: x + 1, y });\n            if (y > 0)\n                coordinates.push({ x: x + 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x + 1, y: y + 1 });\n        }\n\n        return coordinates;\n    }\n}\n","export type Rectangle = { x: number, y: number, width: number, height: number };\n\nexport class MinesweeperLayout {\n    readonly renderSize: { width: number, height: number };\n    readonly gameSize: { width: number, height: number };\n    readonly cellSize: number;\n    readonly minefieldBounds: Rectangle;\n\n    constructor(renderWidth: number, renderHeight: number, gameWidth: number, gameHeight: number) {\n        this.renderSize = { width: renderWidth, height: renderHeight };\n        this.gameSize = { width: gameWidth, height: gameHeight };\n\n        const outerBounds = { x: 0, y: 0, width: this.renderSize.width, height: this.renderSize.height };\n        const aspect = { width: gameWidth, height: gameHeight };\n        this.minefieldBounds = MinesweeperLayout.fitRectangle(aspect, outerBounds);\n\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n\n    getCellCoordinatesByMouseLocation(mouseLocation: { x: number, y: number }): { x: number, y: number } | null {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n\n        return { x, y };\n    }\n\n    getCellBorderX(cellX: number): number {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n\n    getCellBorderY(cellY: number): number {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n\n    getCellBounds(cellX: number, cellY: number): { x: number, y: number, width: number, height: number } {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n\n        return {\n            x,\n            y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y,\n        };\n    }\n\n    private static fitRectangle(aspect: { width: number, height: number }, outerBounds: Rectangle) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            const correctedHeight = outerBounds.width * aspect.height / aspect.width;\n\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight,\n            };\n        } else {\n            const correctedWidth = outerBounds.height * aspect.width / aspect.height;\n\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height,\n            };\n        }\n    }\n}\n","import { Game } from './game';\nimport { Renderer } from './renderer';\n\nconst game = new Game(30, 16, 99);\n\nnew Renderer(game, document.getElementById('minefield-container')!);\n","import { Game, UnknownCell, OpenCell, CellCoords } from './game';\nimport { MinesweeperLayout, Rectangle } from './minesweeperLayout';\n\nexport class Renderer {\n    private readonly game: Game;\n    private readonly minefieldContainer: HTMLElement;\n    private readonly context: CanvasRenderingContext2D;\n    private layout!: MinesweeperLayout;\n    private mouseDownCell: CellCoords | null = null;\n    private isMouseCaptured = false;\n\n    constructor(game: Game, minefieldContainer: HTMLElement) {\n        this.game = game;\n\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!context) throw 'Unable to obtain a 2D drawing context.';\n        this.context = context;\n\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n\n        window.addEventListener('resize', () => this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n\n        canvas.addEventListener('mousedown', ev => this.onMouseDown(ev));\n        canvas.addEventListener('mousemove', ev => this.onMouseMove(ev));\n        canvas.addEventListener('mouseup', ev => this.onMouseUp(ev));\n        canvas.addEventListener('dblclick', ev => this.onDoubleClick(ev));\n        window.addEventListener('contextmenu', ev => ev.preventDefault(), false);\n    }\n\n    private refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n\n        if (this.layout\n            && this.layout.renderSize.width === devicePixelWidth\n            && this.layout.renderSize.height === devicePixelHeight) {\n            return;\n        }\n\n        this.layout = new MinesweeperLayout(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + 'px';\n        canvas.style.height = this.minefieldContainer.clientHeight + 'px';\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n\n    private onMouseDown(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        } else if (ev.button === 2) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.tryToggleMark(coords.x, coords.y))\n                this.render();\n        }\n    }\n\n    private onMouseMove(ev: MouseEvent) {\n        if (this.isMouseCaptured)\n            this.updateMouseDownCell(ev);\n    }\n\n    private onMouseUp(ev: MouseEvent) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n\n            if (this.mouseDownCell) {\n                this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n\n    private onDoubleClick(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y))\n                this.render();\n        }\n    }\n\n    private updateMouseDownCell(ev: MouseEvent) {\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (!Renderer.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n\n    private static areSame(first: CellCoords | null, second: CellCoords | null) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n\n    private getCellByMouseLocation(ev: MouseEvent) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio,\n        });\n    }\n\n    render(): void {\n        const { renderSize, minefieldBounds, cellSize } = this.layout;\n\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n\n        this.context.fillStyle = '#d0d0d0';\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n\n        this.context.strokeStyle = '#a0a0a0';\n\n        for (let y = 0; y < this.game.height; y++) {\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n\n        for (let x = 0; x < this.game.width; x++) {\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n\n        this.context.font = 'bold ' + (cellSize * 0.5) + 'px Georgia';\n\n        for (let y = 0; y < this.game.height; y++) {\n            for (let x = 0; x < this.game.width; x++) {\n                this.drawCell({ x, y }, this.layout.getCellBounds(x, y), cellSize);\n            }\n        }\n    }\n\n    private drawCell(coords: CellCoords, cellBounds: Rectangle, cellSize: number) {\n        const { x, y } = coords;\n\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n\n        const cell = this.game.getCellAt(x, y);\n\n        if (cell instanceof UnknownCell && (cell.marked || !isMouseDown)) {\n            const borderSize = cellSize * 0.1;\n\n            const right = cellBounds.x + cellBounds.width;\n            const bottom = cellBounds.y + cellBounds.height;\n\n            this.context.beginPath();\n            this.context.moveTo(cellBounds.x, cellBounds.y);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.closePath();\n            this.context.fillStyle = '#e8e8e8';\n            this.context.fill();\n\n            this.context.beginPath();\n            this.context.moveTo(right, bottom);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.closePath();\n            this.context.fillStyle = '#a0a0a0';\n            this.context.fill();\n        }\n\n        const text\n            = cell instanceof UnknownCell ? (cell.marked ? '🚩' : null)\n                : cell instanceof OpenCell ? (cell.mineCount !== 0 ? cell.mineCount.toString() : null)\n                    : '💥';\n\n        if (text !== null) {\n            if (cell instanceof OpenCell)\n                this.context.fillStyle = ['blue', 'green', '#e00', 'darkblue', 'brown', 'darkcyan', 'black', 'gray'][cell.mineCount - 1];\n\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n\n    private drawCenteredText(text: string, bounds: Rectangle) {\n        const metrics = this.context.measureText(text);\n        this.context.textBaseline = 'middle';\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n"],"names":["UnknownCell","marked","$e9c2cba252b26a2d4d0a305d28b4d186$var$_classCallCheck","this","OpenCell","mineCount","ExplodedCell","Game","width","height","remainingToOpen","gameConclusion","stateMap","Array","y","mineMap","x","state","contents","undefined","initializeMines","explode","openKnownGoodCell","cell","getCellAt","surroundingCoords","getSurroundingCoordinates","openable","markCount","i","length","coords","push","tryOpen","guaranteedCell","fill","plantedCount","Math","floor","random","abs","allSurrounding","surrounding","console","log","knownGoodCells","pop","concat","coordinates","MinesweeperLayout","renderWidth","renderHeight","gameWidth","gameHeight","$f3ca749d92b004c1e368fb10ffb8d1af$var$_classCallCheck","renderSize","gameSize","outerBounds","aspect","minefieldBounds","fitRectangle","cellSize","correctedHeight","correctedWidth","mouseLocation","cellX","cellY","getCellBorderX","getCellBorderY","Renderer","game","minefieldContainer","_this","$d1a53eba475fcb5300536384a6654628$var$_classCallCheck","$d1a53eba475fcb5300536384a6654628$var$_defineProperty","canvas","document","createElement","context","getContext","appendChild","window","addEventListener","refreshCanvasLayout","ev","onMouseDown","onMouseMove","onMouseUp","onDoubleClick","preventDefault","first","second","devicePixelRatio","devicePixelWidth","clientWidth","devicePixelHeight","clientHeight","layout","$f3ca749d92b004c1e368fb10ffb8d1af$export$MinesweeperLayout","style","render","conclusion","button","isMouseCaptured","updateMouseDownCell","getCellByMouseLocation","tryToggleMark","mouseDownCell","openSurroundingIfSatisfied","areSame","getCellCoordinatesByMouseLocation","offsetX","offsetY","_this$layout","clearRect","fillStyle","fillRect","strokeStyle","pixelY","beginPath","moveTo","lineTo","stroke","pixelX","font","drawCell","getCellBounds","cellBounds","isMouseDown","$e9c2cba252b26a2d4d0a305d28b4d186$export$UnknownCell","borderSize","right","bottom","closePath","text","$e9c2cba252b26a2d4d0a305d28b4d186$export$OpenCell","toString","drawCenteredText","bounds","metrics","measureText","textBaseline","fillText","$e9c2cba252b26a2d4d0a305d28b4d186$export$Game","getElementById"],"version":3,"file":"index.6c311a84.js.map"}