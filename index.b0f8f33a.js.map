{"mappings":"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","sources":["<anon>","src/index.ts","src/game.ts","src/renderer.ts","src/minesweeperLayout.ts"],"sourcesContent":["class $e46db5192eb49d53$export$eaa779a0e5689fc5 {\n    constructor(marked){\n        this.marked = marked;\n    }\n}\nclass $e46db5192eb49d53$export$3b1d32246777906f {\n    constructor(mineCount){\n        this.mineCount = mineCount;\n    }\n}\nclass $e46db5192eb49d53$export$ce2e3e0cb02af144 {\n}\nclass $e46db5192eb49d53$export$985739bfa5723e08 {\n    constructor(width, height, mineCount){\n        this.width = width;\n        this.height = height;\n        this.mineCount = mineCount;\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n        this.stateMap = new Array(height);\n        for(let y = 0; y < height; y++)this.stateMap[y] = new Array(width);\n        this.mineMap = null;\n    }\n    get conclusion() {\n        return this.gameConclusion;\n    }\n    getCellAt(x, y) {\n        const state = this.stateMap[y][x];\n        if (state !== \"revealed\") return new $e46db5192eb49d53$export$eaa779a0e5689fc5(state === \"marked\");\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        const contents = this.mineMap[y][x];\n        return contents === \"bomb\" ? new $e46db5192eb49d53$export$ce2e3e0cb02af144() : new $e46db5192eb49d53$export$3b1d32246777906f(contents);\n    }\n    tryToggleMark(x, y) {\n        const state = this.stateMap[y][x];\n        if (state === \"revealed\") return false;\n        this.stateMap[y][x] = state === \"marked\" ? undefined : \"marked\";\n        return true;\n    }\n    tryOpen(x, y) {\n        const state = this.stateMap[y][x];\n        if (state === \"revealed\" || state === \"marked\") return false;\n        if (this.mineMap === null) this.initializeMines({\n            x: x,\n            y: y\n        });\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        const contents = this.mineMap[y][x];\n        if (contents === \"bomb\") this.explode();\n        else this.openKnownGoodCell(x, y);\n        return true;\n    }\n    openSurroundingIfSatisfied(x, y) {\n        const cell = this.getCellAt(x, y);\n        if (cell instanceof $e46db5192eb49d53$export$3b1d32246777906f) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n            const openable = new Array();\n            let markCount = 0;\n            for(let i = 0; i < surroundingCoords.length; i++){\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n                if (state === \"marked\") markCount++;\n                else if (state !== \"revealed\") openable.push(coords);\n            }\n            if (markCount === cell.mineCount) {\n                for(let i = 0; i < openable.length; i++){\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    initializeMines(guaranteedCell) {\n        this.mineMap = new Array(this.height);\n        for(let y = 0; y < this.height; y++)this.mineMap[y] = new Array(this.width).fill(0);\n        for(let plantedCount = 0; plantedCount < this.mineCount;){\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === \"bomb\") continue;\n            this.mineMap[y][x] = \"bomb\";\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for(let i = 0; i < allSurrounding.length; i++){\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== \"bomb\") this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n            plantedCount++;\n        }\n        console.log(this.mineMap);\n    }\n    explode() {\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        this.gameConclusion = \"loss\";\n        for(let y = 0; y < this.height; y++){\n            for(let x = 0; x < this.width; x++)if (this.mineMap[y][x] === \"bomb\") this.stateMap[y][x] = \"revealed\";\n        }\n    }\n    openKnownGoodCell(x, y) {\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        let knownGoodCells = [\n            {\n                x: x,\n                y: y\n            }\n        ];\n        for(;;){\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === \"marked\" || state === \"revealed\") continue;\n            this.stateMap[cell.y][cell.x] = \"revealed\";\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = \"win\";\n                for(let y = 0; y < this.height; y++){\n                    for(let x = 0; x < this.width; x++)if (this.mineMap[y][x] === \"bomb\") this.stateMap[y][x] = \"marked\";\n                }\n                break;\n            }\n            if (this.mineMap[cell.y][cell.x] === 0) knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n    getSurroundingCoordinates(x, y) {\n        const coordinates = new Array();\n        if (y > 0) coordinates.push({\n            x: x,\n            y: y - 1\n        });\n        if (y < this.height - 1) coordinates.push({\n            x: x,\n            y: y + 1\n        });\n        if (x > 0) {\n            coordinates.push({\n                x: x - 1,\n                y: y\n            });\n            if (y > 0) coordinates.push({\n                x: x - 1,\n                y: y - 1\n            });\n            if (y < this.height - 1) coordinates.push({\n                x: x - 1,\n                y: y + 1\n            });\n        }\n        if (x < this.width - 1) {\n            coordinates.push({\n                x: x + 1,\n                y: y\n            });\n            if (y > 0) coordinates.push({\n                x: x + 1,\n                y: y - 1\n            });\n            if (y < this.height - 1) coordinates.push({\n                x: x + 1,\n                y: y + 1\n            });\n        }\n        return coordinates;\n    }\n}\n\n\n\nclass $7e3eb9e0d162670a$export$563248cf1b99493a {\n    constructor(renderWidth, renderHeight, gameWidth, gameHeight){\n        this.renderSize = {\n            width: renderWidth,\n            height: renderHeight\n        };\n        this.gameSize = {\n            width: gameWidth,\n            height: gameHeight\n        };\n        const outerBounds = {\n            x: 0,\n            y: 0,\n            width: this.renderSize.width,\n            height: this.renderSize.height\n        };\n        const aspect = {\n            width: gameWidth,\n            height: gameHeight\n        };\n        this.minefieldBounds = $7e3eb9e0d162670a$export$563248cf1b99493a.fitRectangle(aspect, outerBounds);\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n    getCellCoordinatesByMouseLocation(mouseLocation) {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n        return {\n            x: x,\n            y: y\n        };\n    }\n    getCellBorderX(cellX) {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n    getCellBorderY(cellY) {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n    getCellBounds(cellX, cellY) {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n        return {\n            x: x,\n            y: y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y\n        };\n    }\n    static fitRectangle(aspect, outerBounds) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            const correctedHeight = outerBounds.width * aspect.height / aspect.width;\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight\n            };\n        } else {\n            const correctedWidth = outerBounds.height * aspect.width / aspect.height;\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height\n            };\n        }\n    }\n}\n\n\nclass $621f3774f67738fc$export$88530751e3977073 {\n    constructor(game, minefieldContainer){\n        this.mouseDownCell = null;\n        this.isMouseCaptured = false;\n        this.game = game;\n        const canvas = document.createElement(\"canvas\");\n        canvas.style.touchAction = \"manipulation\";\n        const context = canvas.getContext(\"2d\");\n        if (!context) throw \"Unable to obtain a 2D drawing context.\";\n        this.context = context;\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n        window.addEventListener(\"resize\", ()=>this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n        canvas.addEventListener(\"mousedown\", (ev)=>this.onMouseDown(ev));\n        canvas.addEventListener(\"mousemove\", (ev)=>this.onMouseMove(ev));\n        canvas.addEventListener(\"mouseup\", (ev)=>this.onMouseUp(ev));\n        canvas.addEventListener(\"dblclick\", (ev)=>this.onDoubleClick(ev));\n        canvas.addEventListener(\"contextmenu\", (ev)=>this.onContextMenu(ev), false);\n    }\n    refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n        if (this.layout && this.layout.renderSize.width === devicePixelWidth && this.layout.renderSize.height === devicePixelHeight) return;\n        this.layout = new (0, $7e3eb9e0d162670a$export$563248cf1b99493a)(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + \"px\";\n        canvas.style.height = this.minefieldContainer.clientHeight + \"px\";\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n    onContextMenu(ev) {\n        ev.preventDefault();\n        if (this.game.conclusion) return;\n        const coords = this.getCellByMouseLocation(ev);\n        if (coords && this.game.tryToggleMark(coords.x, coords.y)) this.render();\n    }\n    onMouseDown(ev) {\n        if (this.game.conclusion) return;\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        }\n    // Right-click is already handled by the contextmenu event which is the only way to get long presses working in\n    // touch interfaces, synced to the haptic feedback. Haven’t found a good way to distinguish right-click from\n    // long press. Waiting until mouseup to mark the cell is at least consistent with how left-click behaves.\n    }\n    onMouseMove(ev) {\n        if (this.isMouseCaptured) this.updateMouseDownCell(ev);\n    }\n    onMouseUp(ev) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n            if (this.mouseDownCell) {\n                this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n    onDoubleClick(ev) {\n        if (this.game.conclusion) return;\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y)) this.render();\n        }\n    }\n    updateMouseDownCell(ev) {\n        const coords = this.getCellByMouseLocation(ev);\n        if (!$621f3774f67738fc$export$88530751e3977073.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n    static areSame(first, second) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n    getCellByMouseLocation(ev) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio\n        });\n    }\n    render() {\n        const { renderSize: renderSize, minefieldBounds: minefieldBounds, cellSize: cellSize } = this.layout;\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n        this.context.fillStyle = \"#d0d0d0\";\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n        this.context.strokeStyle = \"#a0a0a0\";\n        for(let y = 0; y < this.game.height; y++){\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n        for(let x = 0; x < this.game.width; x++){\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n        this.context.font = \"bold \" + cellSize * 0.5 + \"px Georgia\";\n        for(let y = 0; y < this.game.height; y++)for(let x = 0; x < this.game.width; x++)this.drawCell({\n            x: x,\n            y: y\n        }, this.layout.getCellBounds(x, y), cellSize);\n    }\n    drawCell(coords, cellBounds, cellSize) {\n        const { x: x, y: y } = coords;\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n        const cell = this.game.getCellAt(x, y);\n        if (cell instanceof (0, $e46db5192eb49d53$export$eaa779a0e5689fc5) && (cell.marked || !isMouseDown)) {\n            const borderSize = cellSize * 0.1;\n            const right = cellBounds.x + cellBounds.width;\n            const bottom = cellBounds.y + cellBounds.height;\n            this.context.beginPath();\n            this.context.moveTo(cellBounds.x, cellBounds.y);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.closePath();\n            this.context.fillStyle = \"#e8e8e8\";\n            this.context.fill();\n            this.context.beginPath();\n            this.context.moveTo(right, bottom);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.closePath();\n            this.context.fillStyle = \"#a0a0a0\";\n            this.context.fill();\n        }\n        const text = cell instanceof (0, $e46db5192eb49d53$export$eaa779a0e5689fc5) ? cell.marked ? \"\\uD83D\\uDEA9\" : null : cell instanceof (0, $e46db5192eb49d53$export$3b1d32246777906f) ? cell.mineCount !== 0 ? cell.mineCount.toString() : null : \"\\uD83D\\uDCA5\";\n        if (text !== null) {\n            if (cell instanceof (0, $e46db5192eb49d53$export$3b1d32246777906f)) this.context.fillStyle = [\n                \"blue\",\n                \"green\",\n                \"#e00\",\n                \"darkblue\",\n                \"brown\",\n                \"darkcyan\",\n                \"black\",\n                \"gray\"\n            ][cell.mineCount - 1];\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n    drawCenteredText(text, bounds) {\n        const metrics = this.context.measureText(text);\n        this.context.textBaseline = \"middle\";\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n\n\nconst $b4e14b6b8da86996$var$game = new (0, $e46db5192eb49d53$export$985739bfa5723e08)(30, 16, 99);\nnew (0, $621f3774f67738fc$export$88530751e3977073)($b4e14b6b8da86996$var$game, document.getElementById(\"minefield-container\"));\n\n\n//# sourceMappingURL=index.b0f8f33a.js.map\n","import { Game } from './game';\nimport { Renderer } from './renderer';\n\nconst game = new Game(30, 16, 99);\n\nnew Renderer(game, document.getElementById('minefield-container')!);\n","export class UnknownCell {\n    constructor(readonly marked: boolean) {\n    }\n}\n\nexport class OpenCell {\n    constructor(readonly mineCount: number) {\n    }\n}\n\nexport class ExplodedCell { }\n\nexport type CellCoords = { x: number, y: number };\n\nexport class Game {\n    private stateMap: (undefined | 'marked' | 'revealed')[][];\n    private mineMap: ('bomb' | number)[][] | null;\n    private remainingToOpen: number;\n    private gameConclusion: (null | 'win' | 'loss');\n\n    constructor(readonly width: number, readonly height: number, readonly mineCount: number) {\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n\n        this.stateMap = new Array(height);\n        for (let y = 0; y < height; y++)\n            this.stateMap[y] = new Array(width);\n\n        this.mineMap = null;\n    }\n\n    get conclusion(): null | 'win' | 'loss' { return this.gameConclusion; }\n\n    getCellAt(x: number, y: number): UnknownCell | ExplodedCell | OpenCell {\n        const state = this.stateMap[y][x];\n\n        if (state !== 'revealed')\n            return new UnknownCell(state === 'marked');\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n        return contents === 'bomb' ? new ExplodedCell() : new OpenCell(contents);\n    }\n\n    tryToggleMark(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed') return false;\n\n        this.stateMap[y][x] = state === 'marked' ? undefined : 'marked';\n        return true;\n    }\n\n    tryOpen(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed' || state === 'marked') return false;\n\n        if (this.mineMap === null)\n            this.initializeMines({ x, y });\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n\n        if (contents === 'bomb')\n            this.explode();\n        else\n            this.openKnownGoodCell(x, y);\n\n        return true;\n    }\n\n    openSurroundingIfSatisfied(x: number, y: number): boolean {\n        const cell = this.getCellAt(x, y);\n\n        if (cell instanceof OpenCell) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n\n            const openable = new Array<CellCoords>();\n            let markCount = 0;\n\n            for (let i = 0; i < surroundingCoords.length; i++) {\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n\n                if (state === 'marked') {\n                    markCount++;\n                } else if (state !== 'revealed') {\n                    openable.push(coords);\n                }\n            }\n\n            if (markCount === cell.mineCount) {\n                for (let i = 0; i < openable.length; i++) {\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private initializeMines(guaranteedCell: CellCoords) {\n        this.mineMap = new Array(this.height);\n        for (let y = 0; y < this.height; y++)\n            this.mineMap[y] = new Array(this.width).fill(0);\n\n        for (let plantedCount = 0; plantedCount < this.mineCount;) {\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === 'bomb') continue;\n\n            this.mineMap[y][x] = 'bomb';\n\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for (let i = 0; i < allSurrounding.length; i++) {\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== 'bomb')\n                    this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n\n            plantedCount++;\n        }\n\n        console.log(this.mineMap);\n    }\n\n    private explode() {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        this.gameConclusion = 'loss';\n\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.mineMap[y][x] === 'bomb') {\n                    this.stateMap[y][x] = 'revealed';\n                }\n            }\n        }\n    }\n\n    private openKnownGoodCell(x: number, y: number) {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        let knownGoodCells = [{ x, y }];\n\n        for (;;) {\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === 'marked' || state === 'revealed') continue;\n\n            this.stateMap[cell.y][cell.x] = 'revealed';\n\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = 'win';\n\n                for (let y = 0; y < this.height; y++) {\n                    for (let x = 0; x < this.width; x++) {\n                        if (this.mineMap[y][x] === 'bomb') {\n                            this.stateMap[y][x] = 'marked';\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            if (this.mineMap[cell.y][cell.x] === 0)\n                knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n\n    private getSurroundingCoordinates(x: number, y: number) {\n        const coordinates = new Array<CellCoords>();\n\n        if (y > 0)\n            coordinates.push({ x, y: y - 1 });\n        if (y < this.height - 1)\n            coordinates.push({ x, y: y + 1 });\n\n        if (x > 0) {\n            coordinates.push({ x: x - 1, y });\n            if (y > 0)\n                coordinates.push({ x: x - 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x - 1, y: y + 1 });\n        }\n\n        if (x < this.width - 1) {\n            coordinates.push({ x: x + 1, y });\n            if (y > 0)\n                coordinates.push({ x: x + 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x + 1, y: y + 1 });\n        }\n\n        return coordinates;\n    }\n}\n","import { Game, UnknownCell, OpenCell, CellCoords } from './game';\nimport { MinesweeperLayout, Rectangle } from './minesweeperLayout';\n\nexport class Renderer {\n    private readonly game: Game;\n    private readonly minefieldContainer: HTMLElement;\n    private readonly context: CanvasRenderingContext2D;\n    private layout!: MinesweeperLayout;\n    private mouseDownCell: CellCoords | null = null;\n    private isMouseCaptured = false;\n\n    constructor(game: Game, minefieldContainer: HTMLElement) {\n        this.game = game;\n\n        const canvas = document.createElement('canvas');\n        canvas.style.touchAction = 'manipulation';\n\n        const context = canvas.getContext('2d');\n        if (!context) throw 'Unable to obtain a 2D drawing context.';\n        this.context = context;\n\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n\n        window.addEventListener('resize', () => this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n\n        canvas.addEventListener('mousedown', ev => this.onMouseDown(ev));\n        canvas.addEventListener('mousemove', ev => this.onMouseMove(ev));\n        canvas.addEventListener('mouseup', ev => this.onMouseUp(ev));\n        canvas.addEventListener('dblclick', ev => this.onDoubleClick(ev));\n        canvas.addEventListener('contextmenu', ev => this.onContextMenu(ev), false);\n    }\n\n    private refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n\n        if (this.layout\n            && this.layout.renderSize.width === devicePixelWidth\n            && this.layout.renderSize.height === devicePixelHeight) {\n            return;\n        }\n\n        this.layout = new MinesweeperLayout(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + 'px';\n        canvas.style.height = this.minefieldContainer.clientHeight + 'px';\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n\n    private onContextMenu(ev: MouseEvent) {\n        ev.preventDefault();\n        if (this.game.conclusion) return;\n\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (coords && this.game.tryToggleMark(coords.x, coords.y))\n            this.render();\n    }\n\n    private onMouseDown(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        }\n\n        // Right-click is already handled by the contextmenu event which is the only way to get long presses working in\n        // touch interfaces, synced to the haptic feedback. Haven’t found a good way to distinguish right-click from\n        // long press. Waiting until mouseup to mark the cell is at least consistent with how left-click behaves.\n    }\n\n    private onMouseMove(ev: MouseEvent) {\n        if (this.isMouseCaptured)\n            this.updateMouseDownCell(ev);\n    }\n\n    private onMouseUp(ev: MouseEvent) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n\n            if (this.mouseDownCell) {\n                this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n\n    private onDoubleClick(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y))\n                this.render();\n        }\n    }\n\n    private updateMouseDownCell(ev: MouseEvent) {\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (!Renderer.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n\n    private static areSame(first: CellCoords | null, second: CellCoords | null) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n\n    private getCellByMouseLocation(ev: MouseEvent) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio,\n        });\n    }\n\n    render(): void {\n        const { renderSize, minefieldBounds, cellSize } = this.layout;\n\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n\n        this.context.fillStyle = '#d0d0d0';\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n\n        this.context.strokeStyle = '#a0a0a0';\n\n        for (let y = 0; y < this.game.height; y++) {\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n\n        for (let x = 0; x < this.game.width; x++) {\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n\n        this.context.font = 'bold ' + (cellSize * 0.5) + 'px Georgia';\n\n        for (let y = 0; y < this.game.height; y++) {\n            for (let x = 0; x < this.game.width; x++) {\n                this.drawCell({ x, y }, this.layout.getCellBounds(x, y), cellSize);\n            }\n        }\n    }\n\n    private drawCell(coords: CellCoords, cellBounds: Rectangle, cellSize: number) {\n        const { x, y } = coords;\n\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n\n        const cell = this.game.getCellAt(x, y);\n\n        if (cell instanceof UnknownCell && (cell.marked || !isMouseDown)) {\n            const borderSize = cellSize * 0.1;\n\n            const right = cellBounds.x + cellBounds.width;\n            const bottom = cellBounds.y + cellBounds.height;\n\n            this.context.beginPath();\n            this.context.moveTo(cellBounds.x, cellBounds.y);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.closePath();\n            this.context.fillStyle = '#e8e8e8';\n            this.context.fill();\n\n            this.context.beginPath();\n            this.context.moveTo(right, bottom);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.closePath();\n            this.context.fillStyle = '#a0a0a0';\n            this.context.fill();\n        }\n\n        const text\n            = cell instanceof UnknownCell ? (cell.marked ? '🚩' : null)\n                : cell instanceof OpenCell ? (cell.mineCount !== 0 ? cell.mineCount.toString() : null)\n                    : '💥';\n\n        if (text !== null) {\n            if (cell instanceof OpenCell)\n                this.context.fillStyle = ['blue', 'green', '#e00', 'darkblue', 'brown', 'darkcyan', 'black', 'gray'][cell.mineCount - 1];\n\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n\n    private drawCenteredText(text: string, bounds: Rectangle) {\n        const metrics = this.context.measureText(text);\n        this.context.textBaseline = 'middle';\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n","export type Rectangle = { x: number, y: number, width: number, height: number };\n\nexport class MinesweeperLayout {\n    readonly renderSize: { width: number, height: number };\n    readonly gameSize: { width: number, height: number };\n    readonly cellSize: number;\n    readonly minefieldBounds: Rectangle;\n\n    constructor(renderWidth: number, renderHeight: number, gameWidth: number, gameHeight: number) {\n        this.renderSize = { width: renderWidth, height: renderHeight };\n        this.gameSize = { width: gameWidth, height: gameHeight };\n\n        const outerBounds = { x: 0, y: 0, width: this.renderSize.width, height: this.renderSize.height };\n        const aspect = { width: gameWidth, height: gameHeight };\n        this.minefieldBounds = MinesweeperLayout.fitRectangle(aspect, outerBounds);\n\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n\n    getCellCoordinatesByMouseLocation(mouseLocation: { x: number, y: number }): { x: number, y: number } | null {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n\n        return { x, y };\n    }\n\n    getCellBorderX(cellX: number): number {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n\n    getCellBorderY(cellY: number): number {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n\n    getCellBounds(cellX: number, cellY: number): { x: number, y: number, width: number, height: number } {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n\n        return {\n            x,\n            y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y,\n        };\n    }\n\n    private static fitRectangle(aspect: { width: number, height: number }, outerBounds: Rectangle) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            const correctedHeight = outerBounds.width * aspect.height / aspect.width;\n\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight,\n            };\n        } else {\n            const correctedWidth = outerBounds.height * aspect.width / aspect.height;\n\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height,\n            };\n        }\n    }\n}\n"],"names":["$e46db5192eb49d53$export$eaa779a0e5689fc5","constructor","marked","$e46db5192eb49d53$export$3b1d32246777906f","mineCount","$e46db5192eb49d53$export$ce2e3e0cb02af144","$7e3eb9e0d162670a$export$563248cf1b99493a","renderWidth","renderHeight","gameWidth","gameHeight","renderSize","width","height","gameSize","outerBounds","x","y","minefieldBounds","fitRectangle","cellSize","getCellCoordinatesByMouseLocation","mouseLocation","Math","floor","getCellBorderX","cellX","getCellBorderY","cellY","getCellBounds","aspect","correctedHeight","correctedWidth","$621f3774f67738fc$export$88530751e3977073","game","minefieldContainer","mouseDownCell","isMouseCaptured","canvas","document","createElement","style","touchAction","context","getContext","appendChild","window","addEventListener","refreshCanvasLayout","ev","onMouseDown","onMouseMove","onMouseUp","onDoubleClick","onContextMenu","devicePixelRatio","devicePixelWidth","clientWidth","devicePixelHeight","clientHeight","layout","render","preventDefault","conclusion","coords","getCellByMouseLocation","tryToggleMark","button","updateMouseDownCell","tryOpen","openSurroundingIfSatisfied","areSame","first","second","offsetX","offsetY","clearRect","fillStyle","fillRect","strokeStyle","pixelY","beginPath","moveTo","lineTo","stroke","pixelX","font","drawCell","cellBounds","isMouseDown","cell","getCellAt","borderSize","right","bottom","closePath","fill","text","toString","drawCenteredText","bounds","metrics","measureText","textBaseline","fillText","remainingToOpen","gameConclusion","stateMap","Array","mineMap","state","contents","undefined","initializeMines","explode","openKnownGoodCell","surroundingCoords","getSurroundingCoordinates","openable","markCount","i","length","push","guaranteedCell","plantedCount","random","abs","allSurrounding","surrounding","console","log","knownGoodCells","pop","concat","coordinates","getElementById"],"version":3,"file":"index.b0f8f33a.js.map"}