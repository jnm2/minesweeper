{"mappings":"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","sources":["<anon>","src/index.ts","src/game.ts","src/renderer.ts","src/Heatmap.ts","src/minesweeperLayout.ts"],"sourcesContent":["class $e46db5192eb49d53$export$eaa779a0e5689fc5 {\n    constructor(marked){\n        this.marked = marked;\n    }\n}\nclass $e46db5192eb49d53$export$3b1d32246777906f {\n    constructor(mineCount){\n        this.mineCount = mineCount;\n    }\n}\nclass $e46db5192eb49d53$export$ce2e3e0cb02af144 {\n}\nclass $e46db5192eb49d53$export$985739bfa5723e08 {\n    constructor(width, height, mineCount){\n        this.width = width;\n        this.height = height;\n        this.mineCount = mineCount;\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n        this.stateMap = new Array(height);\n        for(let y = 0; y < height; y++)this.stateMap[y] = new Array(width);\n        this.mineMap = null;\n    }\n    get conclusion() {\n        return this.gameConclusion;\n    }\n    getCellAt(x, y) {\n        const state = this.stateMap[y][x];\n        if (state !== \"revealed\") return new $e46db5192eb49d53$export$eaa779a0e5689fc5(state === \"marked\");\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        const contents = this.mineMap[y][x];\n        return contents === \"bomb\" ? new $e46db5192eb49d53$export$ce2e3e0cb02af144() : new $e46db5192eb49d53$export$3b1d32246777906f(contents);\n    }\n    tryToggleMark(x, y) {\n        const state = this.stateMap[y][x];\n        if (state === \"revealed\") return false;\n        this.stateMap[y][x] = state === \"marked\" ? undefined : \"marked\";\n        return true;\n    }\n    canOpen(x, y) {\n        const state = this.stateMap[y][x];\n        return state !== \"revealed\" && state !== \"marked\";\n    }\n    tryOpen(x, y) {\n        if (!this.canOpen(x, y)) return false;\n        if (this.mineMap === null) this.initializeMines({\n            x: x,\n            y: y\n        });\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        const contents = this.mineMap[y][x];\n        if (contents === \"bomb\") this.explode();\n        else this.openKnownGoodCell(x, y);\n        return true;\n    }\n    openSurroundingIfSatisfied(x, y) {\n        const cell = this.getCellAt(x, y);\n        if (cell instanceof $e46db5192eb49d53$export$3b1d32246777906f) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n            const openable = new Array();\n            let markCount = 0;\n            for(let i = 0; i < surroundingCoords.length; i++){\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n                if (state === \"marked\") markCount++;\n                else if (state !== \"revealed\") openable.push(coords);\n            }\n            if (markCount === cell.mineCount) {\n                for(let i = 0; i < openable.length; i++){\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    initializeMines(guaranteedCell) {\n        this.mineMap = new Array(this.height);\n        for(let y = 0; y < this.height; y++)this.mineMap[y] = new Array(this.width).fill(0);\n        for(let plantedCount = 0; plantedCount < this.mineCount;){\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === \"bomb\") continue;\n            this.mineMap[y][x] = \"bomb\";\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for(let i = 0; i < allSurrounding.length; i++){\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== \"bomb\") this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n            plantedCount++;\n        }\n    }\n    explode() {\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        this.gameConclusion = \"loss\";\n        for(let y = 0; y < this.height; y++){\n            for(let x = 0; x < this.width; x++)if (this.mineMap[y][x] === \"bomb\") this.stateMap[y][x] = \"revealed\";\n        }\n    }\n    openKnownGoodCell(x, y) {\n        if (!this.mineMap) throw \"mineMap should be initialized before any cell state is revealed.\";\n        let knownGoodCells = [\n            {\n                x: x,\n                y: y\n            }\n        ];\n        for(;;){\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === \"marked\" || state === \"revealed\") continue;\n            this.stateMap[cell.y][cell.x] = \"revealed\";\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = \"win\";\n                for(let y = 0; y < this.height; y++){\n                    for(let x = 0; x < this.width; x++)if (this.mineMap[y][x] === \"bomb\") this.stateMap[y][x] = \"marked\";\n                }\n                break;\n            }\n            if (this.mineMap[cell.y][cell.x] === 0) knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n    getSurroundingCoordinates(x, y) {\n        const coordinates = new Array();\n        if (y > 0) coordinates.push({\n            x: x,\n            y: y - 1\n        });\n        if (y < this.height - 1) coordinates.push({\n            x: x,\n            y: y + 1\n        });\n        if (x > 0) {\n            coordinates.push({\n                x: x - 1,\n                y: y\n            });\n            if (y > 0) coordinates.push({\n                x: x - 1,\n                y: y - 1\n            });\n            if (y < this.height - 1) coordinates.push({\n                x: x - 1,\n                y: y + 1\n            });\n        }\n        if (x < this.width - 1) {\n            coordinates.push({\n                x: x + 1,\n                y: y\n            });\n            if (y > 0) coordinates.push({\n                x: x + 1,\n                y: y - 1\n            });\n            if (y < this.height - 1) coordinates.push({\n                x: x + 1,\n                y: y + 1\n            });\n        }\n        return coordinates;\n    }\n}\n\n\n\nclass $687393886e0e2604$var$Constraint {\n    constructor(surroundingBombCount, surroundingCoords){\n        this.surroundingBombCount = surroundingBombCount;\n        this.surroundingCoords = surroundingCoords;\n    }\n    validate(map) {\n        let flagCount = 0;\n        let unopenedCount = 0;\n        for (const { x: x, y: y } of this.surroundingCoords)switch(map.cells[y][x]){\n            case \"flag\":\n                flagCount++;\n            // (fallthrough)\n            case undefined:\n                unopenedCount++;\n        }\n        return flagCount <= this.surroundingBombCount && this.surroundingBombCount <= unopenedCount;\n    }\n}\nclass $687393886e0e2604$export$a5c7b93649eaf8f8 {\n    constructor(cells){\n        this.cells = cells;\n    }\n    static fromGame(game) {\n        const rows = new Array(game.height);\n        for(let y = 0; y < rows.length; y++){\n            const cells = new Array(game.width);\n            for(let x = 0; x < cells.length; x++){\n                const cell = game.getCellAt(x, y);\n                cells[x] = cell instanceof (0, $e46db5192eb49d53$export$eaa779a0e5689fc5) ? cell.marked ? \"flag\" : undefined : cell instanceof (0, $e46db5192eb49d53$export$ce2e3e0cb02af144) ? \"flag\" : cell instanceof (0, $e46db5192eb49d53$export$3b1d32246777906f) ? cell.mineCount : undefined;\n            }\n            rows[y] = cells;\n        }\n        return new $687393886e0e2604$export$a5c7b93649eaf8f8(rows);\n    }\n    getCellAt(coords) {\n        return this.cells[coords.y][coords.x];\n    }\n    getSurroundingCellCoords(x, y) {\n        return [\n            {\n                x: x - 1,\n                y: y - 1\n            },\n            {\n                x: x,\n                y: y - 1\n            },\n            {\n                x: x + 1,\n                y: y - 1\n            },\n            {\n                x: x - 1,\n                y: y\n            },\n            {\n                x: x + 1,\n                y: y\n            },\n            {\n                x: x - 1,\n                y: y + 1\n            },\n            {\n                x: x,\n                y: y + 1\n            },\n            {\n                x: x + 1,\n                y: y + 1\n            }\n        ].filter((c)=>c.x >= 0 && c.y >= 0 && c.y < this.cells.length && c.x < this.cells[c.y].length);\n    }\n    getFlagCount() {\n        let count = 0;\n        for(let y = 0; y < this.cells.length; y++){\n            for(let x = 0; x < this.cells[y].length; x++)if (this.cells[y][x] === \"flag\") count++;\n        }\n        return count;\n    }\n    getUnopenedUnflaggedCount() {\n        let count = 0;\n        for(let y = 0; y < this.cells.length; y++){\n            for(let x = 0; x < this.cells[y].length; x++)if (this.cells[y][x] === undefined) count++;\n        }\n        return count;\n    }\n    getValidMapWith(newValue, at) {\n        const rows = this.cells.slice();\n        const cells = rows[at.y].slice();\n        cells[at.x] = newValue;\n        rows[at.y] = cells;\n        const map = new $687393886e0e2604$export$a5c7b93649eaf8f8(rows);\n        for (const coords of map.getSurroundingCellCoords(at.x, at.y)){\n            const cell = map.getCellAt(coords);\n            if (typeof cell === \"number\") {\n                const constraint = new $687393886e0e2604$var$Constraint(cell, map.getSurroundingCellCoords(coords.x, coords.y));\n                if (!constraint.validate(map)) return null;\n            }\n        }\n        return map;\n    }\n    validateAll(totalMineCount) {\n        let flagCount = 0;\n        let unopenedCount = 0;\n        for(let y = 0; y < this.cells.length; y++)for(let x = 0; x < this.cells[y].length; x++){\n            const cell = this.cells[y][x];\n            if (typeof cell === \"number\") {\n                const constraint = new $687393886e0e2604$var$Constraint(cell, this.getSurroundingCellCoords(x, y));\n                if (!constraint.validate(this)) return false;\n            } else if (cell === \"flag\") {\n                flagCount++;\n                if (flagCount > totalMineCount) return false;\n            } else unopenedCount++;\n        }\n        return unopenedCount + flagCount >= totalMineCount;\n    }\n}\nclass $687393886e0e2604$export$48abf8607da8ba96 {\n    constructor(candidates, bombLikelihoodElsewhere){\n        this.candidates = candidates;\n        this.bombLikelihoodElsewhere = bombLikelihoodElsewhere;\n    }\n    getBombLikelihood(x, y) {\n        return this.candidates.find((c)=>c.x === x && c.y === y)?.bombLikelihood ?? this.bombLikelihoodElsewhere;\n    }\n    static compute(game) {\n        const map = game instanceof (0, $e46db5192eb49d53$export$985739bfa5723e08) ? $687393886e0e2604$export$a5c7b93649eaf8f8.fromGame(game) : game.map;\n        const originalAdjacentUnopened = getAllAdjacentUnopened(map);\n        const solutions = new Array();\n        if (map.validateAll(game.mineCount)) visit(map, map.getFlagCount(), map.getUnopenedUnflaggedCount());\n        function visit(map, currentFlagCount, currentUnopenedUnflaggedCount) {\n            if (map === null) return;\n            const next = findAdjacentUnopened(map);\n            if (next === undefined) {\n                solutions.push(map);\n                return;\n            }\n            if (currentUnopenedUnflaggedCount > game.mineCount - currentFlagCount) visit(map.getValidMapWith(\"safe\", next), currentFlagCount, currentUnopenedUnflaggedCount - 1);\n            if (currentFlagCount < game.mineCount) visit(map.getValidMapWith(\"flag\", next), currentFlagCount + 1, currentUnopenedUnflaggedCount - 1);\n        }\n        function findAdjacentUnopened(map) {\n            for (const coord of originalAdjacentUnopened){\n                if (map.getCellAt(coord) === undefined) return coord;\n            }\n        }\n        if (solutions.length === 0) return new $687393886e0e2604$export$48abf8607da8ba96([]);\n        function getAllAdjacentUnopened(map) {\n            const coords = new Array();\n            for(let y = 0; y < map.cells.length; y++){\n                for(let x = 0; x < map.cells[y].length; x++)if (map.cells[y][x] === undefined) {\n                    const surroundingCoords = map.getSurroundingCellCoords(x, y);\n                    if (surroundingCoords.some((c)=>typeof map.getCellAt(c) === \"number\")) coords.push({\n                        x: x,\n                        y: y\n                    });\n                }\n            }\n            return coords;\n        }\n        const averageFlagCount = solutions.reduce((prev, solution)=>prev + solution.getFlagCount(), 0) / solutions.length;\n        const averageRemainingMines = game.mineCount - averageFlagCount;\n        const nonadjacentUnopenedCellCount = map.getUnopenedUnflaggedCount() - originalAdjacentUnopened.length;\n        const bombLikelihoodElsewhere = averageRemainingMines / nonadjacentUnopenedCellCount;\n        return new $687393886e0e2604$export$48abf8607da8ba96(originalAdjacentUnopened.map((coords)=>({\n                ...coords,\n                bombLikelihood: solutions.reduce((prev, solution)=>prev + (solution.getCellAt(coords) === \"flag\" ? 1 : 0), 0) / solutions.length\n            })), bombLikelihoodElsewhere);\n    }\n}\n\n\n\nclass $7e3eb9e0d162670a$export$563248cf1b99493a {\n    constructor(renderWidth, renderHeight, gameWidth, gameHeight){\n        this.renderSize = {\n            width: renderWidth,\n            height: renderHeight\n        };\n        this.gameSize = {\n            width: gameWidth,\n            height: gameHeight\n        };\n        const outerBounds = {\n            x: 0,\n            y: 0,\n            width: this.renderSize.width,\n            height: this.renderSize.height\n        };\n        const aspect = {\n            width: gameWidth,\n            height: gameHeight\n        };\n        this.minefieldBounds = $7e3eb9e0d162670a$export$563248cf1b99493a.fitRectangle(aspect, outerBounds);\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n    getCellCoordinatesByMouseLocation(mouseLocation) {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n        return {\n            x: x,\n            y: y\n        };\n    }\n    getCellBorderX(cellX) {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n    getCellBorderY(cellY) {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n    getCellBounds(cellX, cellY) {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n        return {\n            x: x,\n            y: y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y\n        };\n    }\n    static fitRectangle(aspect, outerBounds) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            const correctedHeight = outerBounds.width * aspect.height / aspect.width;\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight\n            };\n        } else {\n            const correctedWidth = outerBounds.height * aspect.width / aspect.height;\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height\n            };\n        }\n    }\n}\n\n\nclass $621f3774f67738fc$export$88530751e3977073 {\n    constructor(game, minefieldContainer){\n        this.mouseDownCell = null;\n        this.isMouseCaptured = false;\n        this.heatmap = null;\n        this.drawHeatmap = false;\n        this.alwaysDrawHeatmap = false;\n        this.drawBestMoves = false;\n        this.alwaysDrawBestMoves = false;\n        this.teachBestMoves = false;\n        this.autoFlag = false;\n        this.autoOpen = false;\n        this.game = game;\n        const canvas = document.createElement(\"canvas\");\n        canvas.style.touchAction = \"manipulation\";\n        const context = canvas.getContext(\"2d\");\n        if (!context) throw \"Unable to obtain a 2D drawing context.\";\n        this.context = context;\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n        window.addEventListener(\"resize\", ()=>this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n        canvas.addEventListener(\"mousedown\", (ev)=>this.onMouseDown(ev));\n        canvas.addEventListener(\"mousemove\", (ev)=>this.onMouseMove(ev));\n        canvas.addEventListener(\"mouseup\", (ev)=>this.onMouseUp(ev));\n        canvas.addEventListener(\"dblclick\", (ev)=>this.onDoubleClick(ev));\n        canvas.addEventListener(\"contextmenu\", (ev)=>this.onContextMenu(ev), false);\n        window.addEventListener(\"keypress\", (ev)=>this.onKeyPress(ev));\n    }\n    refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n        if (this.layout && this.layout.renderSize.width === devicePixelWidth && this.layout.renderSize.height === devicePixelHeight) return;\n        this.layout = new (0, $7e3eb9e0d162670a$export$563248cf1b99493a)(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + \"px\";\n        canvas.style.height = this.minefieldContainer.clientHeight + \"px\";\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n    onContextMenu(ev) {\n        ev.preventDefault();\n        if (this.game.conclusion) return;\n        const coords = this.getCellByMouseLocation(ev);\n        if (coords && this.game.tryToggleMark(coords.x, coords.y)) {\n            this.afterMove();\n            this.render();\n        }\n    }\n    onMouseDown(ev) {\n        if (this.game.conclusion) return;\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        }\n    // Right-click is already handled by the contextmenu event which is the only way to get long presses working in\n    // touch interfaces, synced to the haptic feedback. Haven’t found a good way to distinguish right-click from\n    // long press. Waiting until mouseup to mark the cell is at least consistent with how left-click behaves.\n    }\n    onMouseMove(ev) {\n        if (this.isMouseCaptured) this.updateMouseDownCell(ev);\n    }\n    onMouseUp(ev) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n            if (this.mouseDownCell) {\n                if (this.game.canOpen(this.mouseDownCell.x, this.mouseDownCell.y)) {\n                    let skipMove = false;\n                    if (this.teachBestMoves && !this.drawBestMoves && this.heatmap !== null) {\n                        const loseLikelihood = this.heatmap.getBombLikelihood(this.mouseDownCell.x, this.mouseDownCell.y);\n                        if (loseLikelihood !== undefined && loseLikelihood > this.getBestMoveLoseLikelihood()) {\n                            this.drawBestMoves = true;\n                            skipMove = true;\n                        }\n                    }\n                    if (!skipMove) {\n                        this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                        this.afterMove();\n                    }\n                }\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n    onKeyPress(ev) {\n        switch(ev.key){\n            case \"h\":\n                this.drawHeatmap = !this.drawHeatmap;\n                this.render();\n                break;\n            case \"H\":\n                this.alwaysDrawHeatmap = !this.alwaysDrawHeatmap;\n                this.drawHeatmap = this.alwaysDrawHeatmap;\n                this.render();\n                break;\n            case \"b\":\n                this.drawBestMoves = !this.drawBestMoves;\n                this.render();\n                break;\n            case \"B\":\n                this.alwaysDrawBestMoves = !this.alwaysDrawBestMoves;\n                this.drawBestMoves = this.alwaysDrawBestMoves;\n                this.render();\n                break;\n            case \"t\":\n                this.teachBestMoves = !this.teachBestMoves;\n                break;\n            case \"a\":\n                this.autoFlag = !this.autoFlag;\n                this.automate();\n                break;\n            case \"A\":\n                this.autoOpen = !this.autoOpen;\n                this.automate();\n                break;\n        }\n    }\n    afterMove() {\n        if (!this.alwaysDrawHeatmap) this.drawHeatmap = false;\n        if (!this.alwaysDrawBestMoves) this.drawBestMoves = false;\n        this.heatmap = (0, $687393886e0e2604$export$48abf8607da8ba96).compute(this.game);\n        this.automate();\n    }\n    automate() {\n        if (this.heatmap === null) return;\n        let needsRender = false;\n        while(true){\n            let anyChange = false;\n            if (this.autoFlag) {\n                for (const candidate of this.heatmap.candidates)if (candidate.bombLikelihood === 1) {\n                    this.game.tryToggleMark(candidate.x, candidate.y);\n                    // Heatmap still needs to be updated; otherwise, 'best move' will be referring to marking a flag which is already marked.\n                    anyChange = true;\n                }\n            }\n            if (this.autoOpen) {\n                for (const candidate of this.heatmap.candidates)if (candidate.bombLikelihood === 0) {\n                    this.game.tryOpen(candidate.x, candidate.y);\n                    anyChange = true;\n                }\n            }\n            if (!anyChange) break;\n            needsRender = true;\n            this.heatmap = (0, $687393886e0e2604$export$48abf8607da8ba96).compute(this.game);\n        }\n        if (needsRender) this.render();\n    }\n    onDoubleClick(ev) {\n        if (this.game.conclusion) return;\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y)) {\n                this.afterMove();\n                this.render();\n            }\n        }\n    }\n    updateMouseDownCell(ev) {\n        const coords = this.getCellByMouseLocation(ev);\n        if (!$621f3774f67738fc$export$88530751e3977073.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n    static areSame(first, second) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n    getCellByMouseLocation(ev) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio\n        });\n    }\n    render() {\n        const { renderSize: renderSize, minefieldBounds: minefieldBounds, cellSize: cellSize } = this.layout;\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n        this.context.fillStyle = \"#d0d0d0\";\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n        this.context.strokeStyle = \"#a0a0a0\";\n        this.context.lineWidth = 1;\n        for(let y = 0; y < this.game.height; y++){\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n        for(let x = 0; x < this.game.width; x++){\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n        this.context.font = \"bold \" + cellSize * 0.5 + \"px Georgia\";\n        const drawBestMovesAtLoseLikelihood = this.drawBestMoves && this.game.conclusion === null ? this.getBestMoveLoseLikelihood() : null;\n        for(let y = 0; y < this.game.height; y++)for(let x = 0; x < this.game.width; x++)this.drawCell({\n            x: x,\n            y: y\n        }, this.layout.getCellBounds(x, y), cellSize, drawBestMovesAtLoseLikelihood);\n    }\n    getBestMoveLoseLikelihood() {\n        if (this.heatmap === null) return null;\n        if (this.heatmap.candidates.some((c)=>c.bombLikelihood === 0 || c.bombLikelihood === 1)) return 0;\n        return Math.min(...this.heatmap.candidates.map((c)=>c.bombLikelihood), ...this.heatmap.bombLikelihoodElsewhere !== undefined ? [\n            this.heatmap.bombLikelihoodElsewhere\n        ] : []);\n    }\n    drawCell(coords, cellBounds, cellSize, drawBestMovesAtLoseLikelihood) {\n        const { x: x, y: y } = coords;\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n        const cell = this.game.getCellAt(x, y);\n        if (cell instanceof (0, $e46db5192eb49d53$export$eaa779a0e5689fc5)) {\n            if (cell.marked || !isMouseDown) {\n                const borderSize = cellSize * 0.1;\n                const right = cellBounds.x + cellBounds.width;\n                const bottom = cellBounds.y + cellBounds.height;\n                this.context.beginPath();\n                this.context.moveTo(cellBounds.x, cellBounds.y);\n                this.context.lineTo(cellBounds.x, bottom);\n                this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n                this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n                this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n                this.context.lineTo(right, cellBounds.y);\n                this.context.closePath();\n                this.context.fillStyle = \"#e8e8e8\";\n                this.context.fill();\n                this.context.beginPath();\n                this.context.moveTo(right, bottom);\n                this.context.lineTo(right, cellBounds.y);\n                this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n                this.context.lineTo(right - borderSize, bottom - borderSize);\n                this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n                this.context.lineTo(cellBounds.x, bottom);\n                this.context.closePath();\n                this.context.fillStyle = \"#a0a0a0\";\n                this.context.fill();\n            }\n            if (!cell.marked) {\n                const bombLikelihood = this.heatmap?.getBombLikelihood(x, y);\n                if (this.drawHeatmap) {\n                    const drawAtFullCertainty = true;\n                    if (bombLikelihood !== undefined && (drawAtFullCertainty || bombLikelihood !== 0 && bombLikelihood !== 1)) {\n                        this.context.fillStyle = `hsl(${(1 - bombLikelihood) * 120} 100% 50% / 25%)`;\n                        this.context.fillRect(cellBounds.x, cellBounds.y, cellBounds.width, cellBounds.height);\n                    }\n                }\n                if (drawBestMovesAtLoseLikelihood !== null) {\n                    if (bombLikelihood === 1 || bombLikelihood === drawBestMovesAtLoseLikelihood) {\n                        this.context.strokeStyle = \"rgba(255, 255, 0, 0.5)\";\n                        this.context.lineWidth = 6;\n                        this.context.strokeRect(cellBounds.x + 2, cellBounds.y + 2, cellBounds.width - 5, cellBounds.height - 5);\n                    }\n                }\n            }\n        }\n        const text = cell instanceof (0, $e46db5192eb49d53$export$eaa779a0e5689fc5) ? cell.marked ? \"\\uD83D\\uDEA9\" : null : cell instanceof (0, $e46db5192eb49d53$export$3b1d32246777906f) ? cell.mineCount !== 0 ? cell.mineCount.toString() : null : \"\\uD83D\\uDCA5\";\n        if (text !== null) {\n            if (cell instanceof (0, $e46db5192eb49d53$export$3b1d32246777906f)) this.context.fillStyle = [\n                \"blue\",\n                \"green\",\n                \"#e00\",\n                \"darkblue\",\n                \"brown\",\n                \"darkcyan\",\n                \"black\",\n                \"gray\"\n            ][cell.mineCount - 1];\n            else this.context.fillStyle = \"black\";\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n    drawCenteredText(text, bounds) {\n        const metrics = this.context.measureText(text);\n        this.context.textBaseline = \"middle\";\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n\n\nconst $b4e14b6b8da86996$var$game = new (0, $e46db5192eb49d53$export$985739bfa5723e08)(30, 16, 99);\nnew (0, $621f3774f67738fc$export$88530751e3977073)($b4e14b6b8da86996$var$game, document.getElementById(\"minefield-container\"));\n\n\n//# sourceMappingURL=index.0826f82e.js.map\n","import { Game } from './game';\nimport { Renderer } from './renderer';\n\nconst game = new Game(30, 16, 99);\n\nnew Renderer(game, document.getElementById('minefield-container')!);\n","export class UnknownCell {\n    constructor(readonly marked: boolean) {\n    }\n}\n\nexport class OpenCell {\n    constructor(readonly mineCount: number) {\n    }\n}\n\nexport class ExplodedCell { }\n\nexport type CellCoords = { x: number, y: number };\n\nexport class Game {\n    private stateMap: (undefined | 'marked' | 'revealed')[][];\n    private mineMap: ('bomb' | number)[][] | null;\n    private remainingToOpen: number;\n    private gameConclusion: (null | 'win' | 'loss');\n\n    constructor(readonly width: number, readonly height: number, readonly mineCount: number) {\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n\n        this.stateMap = new Array(height);\n        for (let y = 0; y < height; y++)\n            this.stateMap[y] = new Array(width);\n\n        this.mineMap = null;\n    }\n\n    get conclusion(): null | 'win' | 'loss' { return this.gameConclusion; }\n\n    getCellAt(x: number, y: number): UnknownCell | ExplodedCell | OpenCell {\n        const state = this.stateMap[y][x];\n\n        if (state !== 'revealed')\n            return new UnknownCell(state === 'marked');\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n        return contents === 'bomb' ? new ExplodedCell() : new OpenCell(contents);\n    }\n\n    tryToggleMark(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed') return false;\n\n        this.stateMap[y][x] = state === 'marked' ? undefined : 'marked';\n        return true;\n    }\n\n    canOpen(x: number, y: number): boolean {\n        const state = this.stateMap[y][x];\n        return state !== 'revealed' && state !== 'marked';\n    }\n\n    tryOpen(x: number, y: number): boolean {\n        if (!this.canOpen(x, y)) return false;\n\n        if (this.mineMap === null)\n            this.initializeMines({ x, y });\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n\n        if (contents === 'bomb')\n            this.explode();\n        else\n            this.openKnownGoodCell(x, y);\n\n        return true;\n    }\n\n    openSurroundingIfSatisfied(x: number, y: number): boolean {\n        const cell = this.getCellAt(x, y);\n\n        if (cell instanceof OpenCell) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n\n            const openable = new Array<CellCoords>();\n            let markCount = 0;\n\n            for (let i = 0; i < surroundingCoords.length; i++) {\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n\n                if (state === 'marked') {\n                    markCount++;\n                } else if (state !== 'revealed') {\n                    openable.push(coords);\n                }\n            }\n\n            if (markCount === cell.mineCount) {\n                for (let i = 0; i < openable.length; i++) {\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private initializeMines(guaranteedCell: CellCoords) {\n        this.mineMap = new Array(this.height);\n        for (let y = 0; y < this.height; y++)\n            this.mineMap[y] = new Array(this.width).fill(0);\n\n        for (let plantedCount = 0; plantedCount < this.mineCount;) {\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === 'bomb') continue;\n\n            this.mineMap[y][x] = 'bomb';\n\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for (let i = 0; i < allSurrounding.length; i++) {\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== 'bomb')\n                    this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n\n            plantedCount++;\n        }\n    }\n\n    private explode() {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        this.gameConclusion = 'loss';\n\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.mineMap[y][x] === 'bomb') {\n                    this.stateMap[y][x] = 'revealed';\n                }\n            }\n        }\n    }\n\n    private openKnownGoodCell(x: number, y: number) {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        let knownGoodCells = [{ x, y }];\n\n        for (;;) {\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === 'marked' || state === 'revealed') continue;\n\n            this.stateMap[cell.y][cell.x] = 'revealed';\n\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = 'win';\n\n                for (let y = 0; y < this.height; y++) {\n                    for (let x = 0; x < this.width; x++) {\n                        if (this.mineMap[y][x] === 'bomb') {\n                            this.stateMap[y][x] = 'marked';\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            if (this.mineMap[cell.y][cell.x] === 0)\n                knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n\n    private getSurroundingCoordinates(x: number, y: number) {\n        const coordinates = new Array<CellCoords>();\n\n        if (y > 0)\n            coordinates.push({ x, y: y - 1 });\n        if (y < this.height - 1)\n            coordinates.push({ x, y: y + 1 });\n\n        if (x > 0) {\n            coordinates.push({ x: x - 1, y });\n            if (y > 0)\n                coordinates.push({ x: x - 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x - 1, y: y + 1 });\n        }\n\n        if (x < this.width - 1) {\n            coordinates.push({ x: x + 1, y });\n            if (y > 0)\n                coordinates.push({ x: x + 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x + 1, y: y + 1 });\n        }\n\n        return coordinates;\n    }\n}\n","import { Heatmap } from './Heatmap';\nimport { Game, UnknownCell, OpenCell, CellCoords } from './game';\nimport { MinesweeperLayout, Rectangle } from './minesweeperLayout';\n\nexport class Renderer {\n    private readonly game: Game;\n    private readonly minefieldContainer: HTMLElement;\n    private readonly context: CanvasRenderingContext2D;\n    private layout!: MinesweeperLayout;\n    private mouseDownCell: CellCoords | null = null;\n    private isMouseCaptured = false;\n    private heatmap: Heatmap | null = null;\n    private drawHeatmap = false;\n    private alwaysDrawHeatmap = false;\n    private drawBestMoves = false;\n    private alwaysDrawBestMoves = false;\n    private teachBestMoves = false;\n    private autoFlag = false;\n    private autoOpen = false;\n\n    constructor(game: Game, minefieldContainer: HTMLElement) {\n        this.game = game;\n\n        const canvas = document.createElement('canvas');\n        canvas.style.touchAction = 'manipulation';\n\n        const context = canvas.getContext('2d');\n        if (!context) throw 'Unable to obtain a 2D drawing context.';\n        this.context = context;\n\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n\n        window.addEventListener('resize', () => this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n\n        canvas.addEventListener('mousedown', ev => this.onMouseDown(ev));\n        canvas.addEventListener('mousemove', ev => this.onMouseMove(ev));\n        canvas.addEventListener('mouseup', ev => this.onMouseUp(ev));\n        canvas.addEventListener('dblclick', ev => this.onDoubleClick(ev));\n        canvas.addEventListener('contextmenu', ev => this.onContextMenu(ev), false);\n\n        window.addEventListener('keypress', ev => this.onKeyPress(ev));\n    }\n\n    private refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n\n        if (this.layout\n            && this.layout.renderSize.width === devicePixelWidth\n            && this.layout.renderSize.height === devicePixelHeight) {\n            return;\n        }\n\n        this.layout = new MinesweeperLayout(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + 'px';\n        canvas.style.height = this.minefieldContainer.clientHeight + 'px';\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n\n    private onContextMenu(ev: MouseEvent) {\n        ev.preventDefault();\n        if (this.game.conclusion) return;\n\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (coords && this.game.tryToggleMark(coords.x, coords.y)) {\n            this.afterMove();\n            this.render();\n        }\n    }\n\n    private onMouseDown(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        }\n\n        // Right-click is already handled by the contextmenu event which is the only way to get long presses working in\n        // touch interfaces, synced to the haptic feedback. Haven’t found a good way to distinguish right-click from\n        // long press. Waiting until mouseup to mark the cell is at least consistent with how left-click behaves.\n    }\n\n    private onMouseMove(ev: MouseEvent) {\n        if (this.isMouseCaptured)\n            this.updateMouseDownCell(ev);\n    }\n\n    private onMouseUp(ev: MouseEvent) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n\n            if (this.mouseDownCell) {\n                if (this.game.canOpen(this.mouseDownCell.x, this.mouseDownCell.y)) {\n                    let skipMove = false;\n\n                    if (this.teachBestMoves && !this.drawBestMoves && this.heatmap !== null) {\n                        const loseLikelihood = this.heatmap.getBombLikelihood(this.mouseDownCell.x, this.mouseDownCell.y);\n                        if (loseLikelihood !== undefined && loseLikelihood > this.getBestMoveLoseLikelihood()!) {\n                            this.drawBestMoves = true;\n                            skipMove = true;\n                        }\n                    }\n\n                    if (!skipMove) {\n                        this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                        this.afterMove();\n                    }\n                }\n\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n\n    private onKeyPress(ev: KeyboardEvent) {\n        switch (ev.key) {\n            case 'h':\n                this.drawHeatmap = !this.drawHeatmap;\n                this.render();\n                break;\n            case 'H':\n                this.alwaysDrawHeatmap = !this.alwaysDrawHeatmap;\n                this.drawHeatmap = this.alwaysDrawHeatmap;\n                this.render();\n                break;\n            case 'b':\n                this.drawBestMoves = !this.drawBestMoves;\n                this.render();\n                break;\n            case 'B':\n                this.alwaysDrawBestMoves = !this.alwaysDrawBestMoves;\n                this.drawBestMoves = this.alwaysDrawBestMoves;\n                this.render();\n                break;\n            case 't':\n                this.teachBestMoves = !this.teachBestMoves;\n                break;\n            case 'a':\n                this.autoFlag = !this.autoFlag;\n                this.automate();\n                break;\n            case 'A':\n                this.autoOpen = !this.autoOpen;\n                this.automate();\n                break;\n        }\n    }\n\n    private afterMove() {\n        if (!this.alwaysDrawHeatmap) this.drawHeatmap = false;\n        if (!this.alwaysDrawBestMoves) this.drawBestMoves = false;\n\n        this.heatmap = Heatmap.compute(this.game);\n        this.automate();\n    }\n\n    private automate() {\n        if (this.heatmap === null) return;\n\n        let needsRender = false;\n\n        while (true) {\n            let anyChange = false;\n\n            if (this.autoFlag) {\n                for (const candidate of this.heatmap.candidates) {\n                    if (candidate.bombLikelihood === 1) {\n                        this.game.tryToggleMark(candidate.x, candidate.y);\n                        // Heatmap still needs to be updated; otherwise, 'best move' will be referring to marking a flag which is already marked.\n                        anyChange = true;\n                    }\n                }\n            }\n\n            if (this.autoOpen) {\n                for (const candidate of this.heatmap.candidates) {\n                    if (candidate.bombLikelihood === 0) {\n                        this.game.tryOpen(candidate.x, candidate.y);\n                        anyChange = true;\n                    }\n                }\n            }\n\n            if (!anyChange) break;\n\n            needsRender = true;\n            this.heatmap = Heatmap.compute(this.game);\n        }\n\n        if (needsRender) this.render();\n    }\n\n    private onDoubleClick(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y)) {\n                this.afterMove();\n                this.render();\n            }\n        }\n    }\n\n    private updateMouseDownCell(ev: MouseEvent) {\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (!Renderer.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n\n    private static areSame(first: CellCoords | null, second: CellCoords | null) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n\n    private getCellByMouseLocation(ev: MouseEvent) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio,\n        });\n    }\n\n    render(): void {\n        const { renderSize, minefieldBounds, cellSize } = this.layout;\n\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n\n        this.context.fillStyle = '#d0d0d0';\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n\n        this.context.strokeStyle = '#a0a0a0';\n        this.context.lineWidth = 1;\n\n        for (let y = 0; y < this.game.height; y++) {\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n\n        for (let x = 0; x < this.game.width; x++) {\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n\n        this.context.font = 'bold ' + (cellSize * 0.5) + 'px Georgia';\n\n        const drawBestMovesAtLoseLikelihood = this.drawBestMoves && this.game.conclusion === null\n            ? this.getBestMoveLoseLikelihood()\n            : null;\n\n        for (let y = 0; y < this.game.height; y++) {\n            for (let x = 0; x < this.game.width; x++) {\n                this.drawCell({ x, y }, this.layout.getCellBounds(x, y), cellSize, drawBestMovesAtLoseLikelihood);\n            }\n        }\n    }\n\n    private getBestMoveLoseLikelihood() {\n        if (this.heatmap === null) return null;\n\n        if (this.heatmap.candidates.some(c => c.bombLikelihood === 0 || c.bombLikelihood === 1))\n            return 0;\n\n        return Math.min(\n            ...this.heatmap.candidates.map(c => c.bombLikelihood),\n            ...(this.heatmap.bombLikelihoodElsewhere !== undefined ? [this.heatmap.bombLikelihoodElsewhere] : []));\n    }\n\n    private drawCell(coords: CellCoords, cellBounds: Rectangle, cellSize: number, drawBestMovesAtLoseLikelihood: number | null) {\n        const { x, y } = coords;\n\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n\n        const cell = this.game.getCellAt(x, y);\n\n        if (cell instanceof UnknownCell) {\n            if (cell.marked || !isMouseDown) {\n                const borderSize = cellSize * 0.1;\n\n                const right = cellBounds.x + cellBounds.width;\n                const bottom = cellBounds.y + cellBounds.height;\n\n                this.context.beginPath();\n                this.context.moveTo(cellBounds.x, cellBounds.y);\n                this.context.lineTo(cellBounds.x, bottom);\n                this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n                this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n                this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n                this.context.lineTo(right, cellBounds.y);\n                this.context.closePath();\n                this.context.fillStyle = '#e8e8e8';\n                this.context.fill();\n\n                this.context.beginPath();\n                this.context.moveTo(right, bottom);\n                this.context.lineTo(right, cellBounds.y);\n                this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n                this.context.lineTo(right - borderSize, bottom - borderSize);\n                this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n                this.context.lineTo(cellBounds.x, bottom);\n                this.context.closePath();\n                this.context.fillStyle = '#a0a0a0';\n                this.context.fill();\n            }\n\n            if (!cell.marked) {\n                const bombLikelihood = this.heatmap?.getBombLikelihood(x, y);\n\n                if (this.drawHeatmap) {\n                    const drawAtFullCertainty = true;\n                    if (bombLikelihood !== undefined && (drawAtFullCertainty || (bombLikelihood !== 0 && bombLikelihood !== 1))) {\n                        this.context.fillStyle = `hsl(${(1 - bombLikelihood) * 120} 100% 50% / 25%)`;\n                        this.context.fillRect(cellBounds.x, cellBounds.y, cellBounds.width, cellBounds.height);\n                    }\n                }\n\n                if (drawBestMovesAtLoseLikelihood !== null) {\n                    if (bombLikelihood === 1 || bombLikelihood === drawBestMovesAtLoseLikelihood) {\n                        this.context.strokeStyle = 'rgba(255, 255, 0, 0.5)';\n                        this.context.lineWidth = 6;\n                        this.context.strokeRect(cellBounds.x + 2, cellBounds.y + 2, cellBounds.width - 5, cellBounds.height - 5);\n                    }\n                }\n            }\n        }\n\n        const text =\n            cell instanceof UnknownCell ? (cell.marked ? '🚩' : null) :\n            cell instanceof OpenCell ? (cell.mineCount !== 0 ? cell.mineCount.toString() : null) :\n            '💥';\n\n        if (text !== null) {\n            if (cell instanceof OpenCell)\n                this.context.fillStyle = ['blue', 'green', '#e00', 'darkblue', 'brown', 'darkcyan', 'black', 'gray'][cell.mineCount - 1];\n            else\n                this.context.fillStyle = 'black';\n\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n\n    private drawCenteredText(text: string, bounds: Rectangle) {\n        const metrics = this.context.measureText(text);\n        this.context.textBaseline = 'middle';\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n","import { CellCoords, ExplodedCell, Game, OpenCell, UnknownCell } from './game';\n\nclass Constraint {\n    constructor(\n        readonly surroundingBombCount: number,\n        readonly surroundingCoords: ReadonlyArray<CellCoords>) {\n    }\n\n    validate(map: Map) {\n        let flagCount = 0;\n        let unopenedCount = 0;\n\n        for (const { x, y } of this.surroundingCoords) {\n            switch (map.cells[y][x]) {\n                case 'flag':\n                    flagCount++;\n                    // (fallthrough)\n                case undefined:\n                    unopenedCount++;\n            }\n        }\n\n        return flagCount <= this.surroundingBombCount\n            && this.surroundingBombCount <= unopenedCount;\n    }\n}\n\nexport class Map {\n    constructor(readonly cells: ReadonlyArray<ReadonlyArray<'flag' | 'safe' | number | undefined>>) {\n    }\n\n    static fromGame(game: Game) {\n        const rows = new Array<('flag' | number | undefined)[]>(game.height);\n\n        for (let y = 0; y < rows.length; y++) {\n            const cells = new Array<('flag' | number | undefined)>(game.width);\n\n            for (let x = 0; x < cells.length; x++) {\n                const cell = game.getCellAt(x, y);\n                cells[x] =\n                    cell instanceof UnknownCell ? (cell.marked ? 'flag' : undefined) :\n                    cell instanceof ExplodedCell ? 'flag' :\n                    cell instanceof OpenCell ? cell.mineCount :\n                    undefined;\n            }\n\n            rows[y] = cells;\n        }\n\n        return new Map(rows);\n    }\n\n    getCellAt(coords: CellCoords) {\n        return this.cells[coords.y][coords.x];\n    }\n\n    getSurroundingCellCoords(x: number, y: number) {\n        return [\n            { x: x - 1, y: y - 1 },\n            { x: x, y: y - 1 },\n            { x: x + 1, y: y - 1 },\n            { x: x - 1, y: y },\n            { x: x + 1, y: y },\n            { x: x - 1, y: y + 1 },\n            { x: x, y: y + 1 },\n            { x: x + 1, y: y + 1 },\n        ].filter(c => c.x >= 0 && c.y >= 0 && c.y < this.cells.length && c.x < this.cells[c.y].length);\n    }\n\n    getFlagCount() {\n        let count = 0;\n\n        for (let y = 0; y < this.cells.length; y++) {\n            for (let x = 0; x < this.cells[y].length; x++) {\n                if (this.cells[y][x] === 'flag')\n                    count++;\n            }\n        }\n\n        return count;\n    }\n\n    getUnopenedUnflaggedCount() {\n        let count = 0;\n\n        for (let y = 0; y < this.cells.length; y++) {\n            for (let x = 0; x < this.cells[y].length; x++) {\n                if (this.cells[y][x] === undefined)\n                    count++;\n            }\n        }\n\n        return count;\n    }\n\n    getValidMapWith(newValue: 'flag' | 'safe', at: CellCoords) {\n        const rows = this.cells.slice();\n\n        const cells = rows[at.y].slice();\n        cells[at.x] = newValue;\n        rows[at.y] = cells;\n\n        const map = new Map(rows);\n\n        for (const coords of map.getSurroundingCellCoords(at.x, at.y)) {\n            const cell = map.getCellAt(coords);\n            if (typeof cell === 'number') {\n                const constraint = new Constraint(cell, map.getSurroundingCellCoords(coords.x, coords.y));\n                if (!constraint.validate(map))\n                    return null;\n            }\n        }\n\n        return map;\n    }\n\n    validateAll(totalMineCount: number) {\n        let flagCount = 0;\n        let unopenedCount = 0;\n\n        for (let y = 0; y < this.cells.length; y++) {\n            for (let x = 0; x < this.cells[y].length; x++) {\n                const cell = this.cells[y][x];\n                if (typeof cell === 'number') {\n                    const constraint = new Constraint(cell, this.getSurroundingCellCoords(x, y));\n                    if (!constraint.validate(this))\n                        return false;\n                } else if (cell === 'flag') {\n                    flagCount++;\n                    if (flagCount > totalMineCount) return false;\n                } else {\n                    unopenedCount++;\n                }\n            }\n        }\n\n        return unopenedCount + flagCount >= totalMineCount;\n    }\n}\n\nexport class Heatmap {\n    constructor(\n        readonly candidates: ReadonlyArray<{ x: number, y: number, bombLikelihood: number }>,\n        readonly bombLikelihoodElsewhere?: number) {\n    }\n\n    getBombLikelihood(x: number, y: number): number | undefined {\n        return this.candidates.find(c => c.x === x && c.y === y)?.bombLikelihood\n            ?? this.bombLikelihoodElsewhere;\n    }\n\n    static compute(game: Game | { map: Map, mineCount: number }): Heatmap {\n        const map = game instanceof Game ? Map.fromGame(game) : game.map;\n        const originalAdjacentUnopened = getAllAdjacentUnopened(map);\n\n        const solutions = new Array<Map>();\n\n        if (map.validateAll(game.mineCount))\n            visit(map, map.getFlagCount(), map.getUnopenedUnflaggedCount());\n\n        function visit(map: Map | null, currentFlagCount: number, currentUnopenedUnflaggedCount: number) {\n            if (map === null) return;\n\n            const next = findAdjacentUnopened(map);\n            if (next === undefined) {\n                solutions.push(map);\n                return;\n            }\n\n            if (currentUnopenedUnflaggedCount > game.mineCount - currentFlagCount)\n                visit(map.getValidMapWith('safe', next), currentFlagCount, currentUnopenedUnflaggedCount - 1);\n            if (currentFlagCount < game.mineCount)\n                visit(map.getValidMapWith('flag', next), currentFlagCount + 1, currentUnopenedUnflaggedCount - 1);\n        }\n\n        function findAdjacentUnopened(map: Map) {\n            for (const coord of originalAdjacentUnopened) {\n                if (map.getCellAt(coord) === undefined)\n                    return coord;\n            }\n        }\n\n        if (solutions.length === 0)\n            return new Heatmap([]);\n\n        function getAllAdjacentUnopened(map: Map) {\n            const coords = new Array<CellCoords>();\n\n            for (let y = 0; y < map.cells.length; y++) {\n                for (let x = 0; x < map.cells[y].length; x++) {\n                    if (map.cells[y][x] === undefined) {\n                        const surroundingCoords = map.getSurroundingCellCoords(x, y);\n                        if (surroundingCoords.some(c => typeof map.getCellAt(c) === 'number'))\n                            coords.push({ x, y });\n                    }\n                }\n            }\n\n            return coords;\n        }\n\n        const averageFlagCount = solutions.reduce(\n            (prev, solution) => prev + solution.getFlagCount(),\n            0) / solutions.length;\n\n        const averageRemainingMines = game.mineCount - averageFlagCount;\n        const nonadjacentUnopenedCellCount = map.getUnopenedUnflaggedCount() - originalAdjacentUnopened.length;\n        const bombLikelihoodElsewhere = averageRemainingMines / nonadjacentUnopenedCellCount;\n\n        return new Heatmap(\n            originalAdjacentUnopened.map(coords => ({\n                ...coords,\n                bombLikelihood: solutions.reduce(\n                    (prev, solution) => prev + (solution.getCellAt(coords) === 'flag' ? 1 : 0),\n                    0) / solutions.length,\n            })),\n            bombLikelihoodElsewhere);\n    }\n}\n","export type Rectangle = { x: number, y: number, width: number, height: number };\n\nexport class MinesweeperLayout {\n    readonly renderSize: { width: number, height: number };\n    readonly gameSize: { width: number, height: number };\n    readonly cellSize: number;\n    readonly minefieldBounds: Rectangle;\n\n    constructor(renderWidth: number, renderHeight: number, gameWidth: number, gameHeight: number) {\n        this.renderSize = { width: renderWidth, height: renderHeight };\n        this.gameSize = { width: gameWidth, height: gameHeight };\n\n        const outerBounds = { x: 0, y: 0, width: this.renderSize.width, height: this.renderSize.height };\n        const aspect = { width: gameWidth, height: gameHeight };\n        this.minefieldBounds = MinesweeperLayout.fitRectangle(aspect, outerBounds);\n\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n\n    getCellCoordinatesByMouseLocation(mouseLocation: { x: number, y: number }): { x: number, y: number } | null {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n\n        return { x, y };\n    }\n\n    getCellBorderX(cellX: number): number {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n\n    getCellBorderY(cellY: number): number {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n\n    getCellBounds(cellX: number, cellY: number): { x: number, y: number, width: number, height: number } {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n\n        return {\n            x,\n            y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y,\n        };\n    }\n\n    private static fitRectangle(aspect: { width: number, height: number }, outerBounds: Rectangle) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            const correctedHeight = outerBounds.width * aspect.height / aspect.width;\n\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight,\n            };\n        } else {\n            const correctedWidth = outerBounds.height * aspect.width / aspect.height;\n\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height,\n            };\n        }\n    }\n}\n"],"names":["$e46db5192eb49d53$export$eaa779a0e5689fc5","constructor","marked","$e46db5192eb49d53$export$3b1d32246777906f","mineCount","$e46db5192eb49d53$export$ce2e3e0cb02af144","$e46db5192eb49d53$export$985739bfa5723e08","width","height","remainingToOpen","gameConclusion","stateMap","Array","y","mineMap","conclusion","getCellAt","x","state","contents","tryToggleMark","undefined","canOpen","tryOpen","initializeMines","explode","openKnownGoodCell","openSurroundingIfSatisfied","cell","surroundingCoords","getSurroundingCoordinates","openable","markCount","i","length","coords","push","guaranteedCell","fill","plantedCount","Math","floor","random","abs","allSurrounding","surrounding","knownGoodCells","pop","concat","coordinates","$687393886e0e2604$var$Constraint","surroundingBombCount","validate","map","flagCount","unopenedCount","cells","$687393886e0e2604$export$a5c7b93649eaf8f8","fromGame","game","rows","getSurroundingCellCoords","filter","c","getFlagCount","count","getUnopenedUnflaggedCount","getValidMapWith","newValue","at","slice","constraint","validateAll","totalMineCount","$687393886e0e2604$export$48abf8607da8ba96","candidates","bombLikelihoodElsewhere","getBombLikelihood","find","bombLikelihood","compute","originalAdjacentUnopened","getAllAdjacentUnopened","some","solutions","visit","currentFlagCount","currentUnopenedUnflaggedCount","next","findAdjacentUnopened","coord","averageFlagCount","reduce","prev","solution","averageRemainingMines","nonadjacentUnopenedCellCount","$7e3eb9e0d162670a$export$563248cf1b99493a","renderWidth","renderHeight","gameWidth","gameHeight","renderSize","gameSize","outerBounds","minefieldBounds","fitRectangle","cellSize","getCellCoordinatesByMouseLocation","mouseLocation","getCellBorderX","cellX","getCellBorderY","cellY","getCellBounds","aspect","correctedHeight","correctedWidth","$621f3774f67738fc$export$88530751e3977073","minefieldContainer","mouseDownCell","isMouseCaptured","heatmap","drawHeatmap","alwaysDrawHeatmap","drawBestMoves","alwaysDrawBestMoves","teachBestMoves","autoFlag","autoOpen","canvas","document","createElement","style","touchAction","context","getContext","appendChild","window","addEventListener","refreshCanvasLayout","ev","onMouseDown","onMouseMove","onMouseUp","onDoubleClick","onContextMenu","onKeyPress","devicePixelRatio","devicePixelWidth","clientWidth","devicePixelHeight","clientHeight","layout","render","preventDefault","getCellByMouseLocation","afterMove","button","updateMouseDownCell","skipMove","loseLikelihood","getBestMoveLoseLikelihood","key","automate","needsRender","anyChange","candidate","areSame","first","second","offsetX","offsetY","clearRect","fillStyle","fillRect","strokeStyle","lineWidth","pixelY","beginPath","moveTo","lineTo","stroke","pixelX","font","drawBestMovesAtLoseLikelihood","drawCell","min","cellBounds","isMouseDown","borderSize","right","bottom","closePath","strokeRect","text","toString","drawCenteredText","bounds","metrics","measureText","textBaseline","fillText","getElementById"],"version":3,"file":"index.0826f82e.js.map"}